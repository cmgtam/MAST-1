% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{MAST Documentation}
\date{February 11, 2014}
\release{20140131.coracle}
\author{University of Wisconsin-Madison Computational Materials Group}
\newcommand{\sphinxlogo}{\includegraphics{MAST_logo_200px.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{0_0_introduction:introduction}\label{0_0_introduction::doc}\label{0_0_introduction:materials-simulation-toolkit-mast-manual}
Welcome to the MAterials Simulation Toolkit (MAST)!

MAST is intended to be an easy-to-use wrapper to facilitate complex sequences of calculations.


\section{The MAST Kitchen}
\label{0_0_introduction:the-mast-kitchen}
MAST uses kitchen terminology to organize the materials simulation workflow.
\begin{itemize}
\item {} 
An {\hyperref[2_0_ingredients::doc]{\emph{Ingredient}}} is a single calculation, like a single VASP calculation resulting in a relaxed structure and energy.

\item {} 
A {\hyperref[4_0_recipe::doc]{\emph{Recipe}}} is a collection of several ingredients and information about how the ingredients are combined together.
\begin{itemize}
\item {} 
As in a cooking recipe, ingredients may need to be addressed in a certain logical order. This temporal order of how ingredients work together is the workflow.

\item {} 
The {\hyperref[4_0_recipe::doc]{\emph{Recipe Template}}} and {\hyperref[3_0_inputfile::doc]{\emph{Input File}}} together describe the order of the ingredients and the way they are combined together.

\end{itemize}

\end{itemize}


\section{Computing in the MAST Kitchen}
\label{0_0_introduction:computing-in-the-mast-kitchen}\begin{enumerate}
\item {} 
Install MAST (see \emph{1\_0\_installation}).

\item {} 
Plan your workflow.
\begin{itemize}
\item {} 
What are the single calculations you will need (Ingredients)?

\item {} 
Which calculations depend on each other and should be grouped into a Recipe?

\item {} 
What are all of the conditions for each calculation (e.g. which ones can have volume change, and which ones should be at fixed volume? How fine a kpoint mesh does each calculation need? etc.)?

\end{itemize}

\item {} 
Start with some of the standard recipes in your \$MAST\_RECIPE\_PATH directory or use a new template.

\item {} 
Create an input file, for example, test.inp.

\item {} 
Run the command \code{mast -i test.inp} to parse the input file.

\item {} 
Under \code{\$MAST\_SCRATCH}, MAST creates a timestamped recipe directory.

\item {} 
Within the recipe directory:
\begin{enumerate}
\item {} 
Each ingredient gets its own directory within the system\_recipe\_timestamp directory.

\item {} 
Additional files are created, including:
\begin{enumerate}
\item {} 
\code{personal\_recipe.txt}, which is your recipe template file filled in with information gathered from the input \code{.inp} file.

\item {} 
\code{archive\_input\_options.txt}, so you can see what the input options originally were

\item {} 
\code{archive\_recipe\_plan.txt}, which tells you how MAST interpreted the recipe file. You can check this file to see which ingredients are considered parents of which other ingredients, for troubleshootin

\item {} 
\code{status.txt}, which tells the status of all the ingredients.

\item {} 
\code{input.inp}, which is a copy of the input file (or an individual loop of a looped input file)

\item {} 
\code{metadata.txt}, which stores metadata information

\item {} 
\code{mast\_recipe.log}, which stores recipe-level logging information.

\end{enumerate}

\end{enumerate}

\item {} 
Run the command \code{mast} to start the MAST scheduling arm. The MAST scheduler will get information from the personal\_recipe.txt, input.inp, and status.txt file in the recipe folder.

\item {} 
When all ingredients in the recipe are complete, the recipe directory is moved into a \code{\$MAST\_ARCHIVE} directory.

\end{enumerate}

Please check your output carefully, especially when setting up a new workflow using MAST.


\chapter{Installation}
\label{1_0_installation:installation}\label{1_0_installation::doc}

\section{Installation}
\label{1_0_installation:id1}

\subsection{Pre-steps}
\label{1_0_installation:pre-steps}
Skip this step if you are on bardeen.
\begin{itemize}
\item {} 
If you are on ACI/HPC, make sure you are using the compile node for all installation tasks. (aci-service-2 as of Dec. 2013) Use the submit node only to submit jobs.

\item {} 
Have the owner of //tmp/pip-build remove the directory if it exists (see \href{https://github.com/pypa/pip/issues/729}{pip issue 729}):

\begin{Verbatim}[commandchars=\\\{\}]
cd //tmp
rm -r pip-build
\end{Verbatim}

\end{itemize}


\subsection{Verify your Python version}
\label{1_0_installation:verify-your-python-version}
Check your version of python: \code{python -{-}version}

If your version of python is not 2.7.3, try to locate an existing version of python 2.7.3.
Then, make sure that this version of python is defaulted to be used first. You may need to add a line similar to your user profile, such as \code{//home/username/.bashrc}
Then, log out and log back in.

For bardeen, the line you need to add is:

\begin{Verbatim}[commandchars=\\\{\}]
export PATH=//share/apps/EPD\_64bit/epd\_free-7.3-2-rh5-x86\_64/bin:\$PATH
\end{Verbatim}

For platforms with the ``module'' system like stampede or DLX, check which modules are available (\code{module avail}) and add a line something like:

\begin{Verbatim}[commandchars=\\\{\}]
module load python
module load Python
\end{Verbatim}

Then, log out and log back in.

Type \code{which python} to make sure you have the right version, or \code{python -{-}version}.

If you already use python for something else and shifting python versions will interfere with other programs, for example, you routinely use Python 2.4.3 instead and your other programs break if called from python 2.7.3, please contact the development team.

If you do not have or cannot find Python 2.7.3, then you must install it.


\subsubsection{Install python}
\label{1_0_installation:install-python}
The EPD/Canopy version is preferred because it includes numpy and scipy already. Download this version from \href{https://www.enthought.com/downloads/}{EPD Free Canopy}
\begin{itemize}
\item {} 
Version 2.7.5 is okay

\item {} 
On DLX, go into interactive setup with the command \code{srun -u bash -i}

\item {} 
\code{bash ./canopy-1.0.3-rh5-64.sh}

\item {} 
Follow the prompts (use spacebar to scroll through the license file)

\end{itemize}

Add lines to your profile to make this python installation your default python:

\begin{Verbatim}[commandchars=\\\{\}]
vi \textasciitilde{}/.bashrc
\#EPD (Canopy) python
export PATH=//home/tma249/Canopy/appdata/canopy-1.0.3.1262.rh5-x86\_64/bin:\$PATH
\end{Verbatim}
\begin{itemize}
\item {} 
Do not just use the .Canopy/bin. directory - python modules will not load properly

\item {} 
Log out and log in

\end{itemize}

Check your version of python: \code{python -{-}version}

The version given must be the correct version. If not, for all subsequent commands that say \emph{python}, give the full path to your version of python, e.g. \code{//share/apps/EPD\_64bit/epd\_free-7.3-2-rh5-x86\_64/bin/python}


\subsection{Verify setuptools (easy\_install) and pip}
\label{1_0_installation:verify-setuptools-easy-install-and-pip}
Check if easy\_install and pip are available:
\begin{itemize}
\item {} 
\code{which pip}

\item {} 
\code{which easy\_install}

\end{itemize}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
[username@aci-service-2 \textasciitilde{}]\$ which pip
//home/username/Canopy/appdata/canopy-1.0.3.1262.rh5-x86\_64/bin/pip
[username@aci-service-2 \textasciitilde{}]\$ which easy\_install
//home/username/Canopy/appdata/canopy-1.0.3.1262.rh5-x86\_64/bin/easy\_install
\end{Verbatim}

pip must be version 1.3 or later (\code{pip -{-}version})

If either easy\_install or pip is missing, install them as follows.

Get setuptools (easy\_install)
\begin{itemize}
\item {} 
\href{https://pypi.python.org/pypi/setuptools}{setuptools}

\item {} 
\code{wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez\_setup.py}

\item {} 
\code{python ez\_setup.py} if you are using your own locally-installed python

\item {} 
\code{python ez\_setup.py -{-}user} if you are using a root-installed python

\end{itemize}

Get pip
\begin{itemize}
\item {} 
\href{https://pypi.python.org/pypi/pip}{pip}

\item {} 
\code{curl -O https://raw.github.com/pypa/pip/master/contrib/get-pip.py}

\item {} 
\code{python get-pip.py} if you are using your own locally-installed python

\item {} 
\code{python get-pip.py -{-}user} if you are using a root-installed python

\end{itemize}

easy\_install and pip should now be located either wherever your installed python is, or in the \code{\$HOME/.local/bin} directory
Check their locations and the pip version again.


\subsection{Verify or install numpy and scipy}
\label{1_0_installation:verify-or-install-numpy-and-scipy}
Check if numpy and scipy available:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}
\end{Verbatim}

If numpy and scipy are not available, we recommend that you go back and install a local version of python which already includes numpy and scipy.

Scipy is optional at this stage (used in the MAST defect finder).


\subsubsection{Install numpy (not recommended)}
\label{1_0_installation:install-numpy-not-recommended}
If numpy is not available, try pip installation:

\begin{Verbatim}[commandchars=\\\{\}]
pip install --user numpy
\end{Verbatim}

(If you are using a user-installed pip with a root-installed python, use the command \code{\$HOME/.local/bin/pip} instead of \code{pip}.)

If pip does not work, follow Quick install of numpy here. This will install Numpy without external library support. It is a quick and easy way to install Numpy, and will suite you for the purposes of running MAST.
\begin{itemize}
\item {} 
Grab the most recent stable release of numpy from \href{http://www.scipy.org/install.html}{http://www.scipy.org/install.html}

\item {} 
Untar with command \code{tar -zxvf numpy-\textless{}version\textgreater{}.tar.gz}

\item {} 
\code{cd numpy-\textless{}version\textgreater{}}

\item {} 
Put the following in your command line, all as one line:

\begin{Verbatim}[commandchars=\\\{\}]
BLAS=None LAPACK=None ATLAS=None
python setup.py config build install
--prefix=\textless{}location where you want numpy installed, recommend \$HOME/lib\textgreater{}
\end{Verbatim}

\item {} 
Get something to drink; this'll take about 5-10 minutes.

\item {} 
Add to your .bashrc:

\begin{Verbatim}[commandchars=\\\{\}]
NUMPY=\textless{}location you specified above\textgreater{}
export PYTHONPATH=\$NUMPY:\$PYTHONPATH
\end{Verbatim}

\item {} 
source \$HOME/.bashrc

\end{itemize}


\subsection{Verify or install pymatgen and custodian}
\label{1_0_installation:verify-or-install-pymatgen-and-custodian}
Check if pymatgen and custodian available:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\PYG{k+kn}{import} \PYG{n+nn}{pymatgen}
\PYG{k+kn}{import} \PYG{n+nn}{custodian}
\end{Verbatim}

If pymatgen and custodian are not available, install them.


\subsubsection{Install pymatgen and custodian}
\label{1_0_installation:install-pymatgen-and-custodian}
Make sure you explicitly use the correct pip and easy\_install, e.g. //home/username/.local/bin/pip and //home/username/.local/bin/easy\_install or other such paths, corresponding to the correct version of python.

Use the \code{-{-}user} tag if you are not using the easy\_install and pip from your own installation of python. Otherwise, you can omit this tag.

Upgrade the \emph{distribute} package. You \textbf{MUST} upgrade this package, even if it is freshly installed. (8/9/13)

\begin{Verbatim}[commandchars=\\\{\}]
nice -n 19 easy\_install --user --upgrade distribute
\end{Verbatim}

pip install pymatgen and custodian:

\begin{Verbatim}[commandchars=\\\{\}]
nice -n 19 pip install --user pymatgen
nice -n 19 pip install --user custodian
\end{Verbatim}

If the pymatgen installation does not work, failing with PyCifRW, install PyCifRW manually first, using the paths that correspond to your system (python line is all one line):

\begin{Verbatim}[commandchars=\\\{\}]
cd \$HOME/.local/lib/python2.7/site-packages/setuptools-2.1-py2.7.egg

python ./easy\_install.py --user https://bitbucket.org/
    jamesrhester/pycifrw/downloads/PyCifRW-3.5-py2.7-linux-i686.egg
\end{Verbatim}

If pip does not work, try making your own temp directory.

\begin{Verbatim}[commandchars=\\\{\}]
mkdir //home/\textless{}username\textgreater{}/tmp
export TMPDIR=.//home/\textless{}username\textgreater{}/tmp.
\end{Verbatim}

Then try running the pip commands again.

Remove any pip directory if it exists.

\begin{Verbatim}[commandchars=\\\{\}]
cd //tmp
rm -r pip-build
\end{Verbatim}


\subsection{Set up the pymatgen VASP\_PSP\_DIR}
\label{1_0_installation:set-up-the-pymatgen-vasp-psp-dir}
On DLX and bardeen, skip to the NEXT NUMBERED STEP

Locate the VASP pseudopotentials
\begin{itemize}
\item {} 
On bardeen, this is \code{//share/apps/vasp\_pseudopotentials}

\item {} 
On DLX it is \code{//home/adozier/VASP}

\end{itemize}

Run pymatgen's python setup tool. This tool should be located wherever pymatgen was installed, either \code{\textasciitilde{}/.local/bin/potcar\_setup.py} if you installed it with \code{-{-}user}, or wherever python is, otherwise.

\begin{Verbatim}[commandchars=\\\{\}]
python .local/bin/potcar\_setup.py or python potcar\_setup.py or simply potcar\_setup.py
\end{Verbatim}

(Remember to use the correct version of python, determined in step 2, e.g. //share/apps/EPD\_64bit/epd\_free-7.3-2-rh5-x86\_64/bin/python .local/bin/potcar\_setup.py)

Take the paw directory if you are using PAW. Do not take the top directory, or the GGA/LDA/etc folders will overwrite.

Example of running the python setup tool:

\begin{Verbatim}[commandchars=\\\{\}]
Please enter full path where the POT\_GGA\_PAW\_PBE, etc.
subdirs are present.
If you obtained the PSPs directly from VASP, this should
typically be the directory that you untar the files to :
//share/apps/vasp\_pseudopotentials/paw
Please enter the fullpath of the where you want to create
your pymatgen resources directory:
//home/\textless{}username\textgreater{}/.local/vasp\_pps
\end{Verbatim}

Rename the folders under \code{//home/\textless{}username\textgreater{}/.local/vasp\_pps}:
\begin{itemize}
\item {} 
Rename the PBE folder POT\_GGA\_PAW\_PBE to correspond to mast\_xc pbe

\item {} 
Rename the GGA folder POT\_GGA\_PAW\_PW91 to correspond to mast\_xc pw91

\end{itemize}


\subsection{Add the VASP\_PSP\_DIR to your user profile}
\label{1_0_installation:add-the-vasp-psp-dir-to-your-user-profile}
Add a line to your .bashrc file exporting the environment variable VASP\_PSP\_DIR to this VASP directory.
\begin{itemize}
\item {} 
On bardeen, it should look something like:

\begin{Verbatim}[commandchars=\\\{\}]
export VASP\_PSP\_DIR=//home/\textless{}username\textgreater{}/.local/vasp\_pps
\end{Verbatim}

\item {} 
On DLX, use the directories already created:

\begin{Verbatim}[commandchars=\\\{\}]
export VASP\_PSP\_DIR=//home/adozier/VASP/resources
export VASP\_PSP\_DIR=\textless{}whichever path you used in the potcar\_setup.py script\textgreater{}
\end{Verbatim}

\item {} 
Remember to save your .bashrc file. Test the change:

\begin{Verbatim}[commandchars=\\\{\}]
source \textasciitilde{}/.bashrc
cd \$VASP\_PSP\_DIR
\end{Verbatim}

\item {} 
Make sure you are getting to the right directory, which has POT\_GGA\_POW\_PBE etc. folders inside it.

\end{itemize}


\subsection{Get MAST}
\label{1_0_installation:get-mast}
Get the MAST tar.gz file from MaterialsHub.org and untar it:

\begin{Verbatim}[commandchars=\\\{\}]
nice -n 19 tar -xzvf mast\_version.tar.gz
\end{Verbatim}

(or run this command over interactive submission, which is better)


\subsection{Set up the environment variables}
\label{1_0_installation:set-up-the-environment-variables}
Go to the MAST installation path, for example \code{//home/username/mast\_version}

Run the command

\begin{Verbatim}[commandchars=\\\{\}]
python initialize.py
\end{Verbatim}

This command should create the \code{home/username/MAST} directory in your home directory, as well as necessary subdirectories and files.
It should also make the MAST bin executables executable.

Choose a platform at the prompt. You must choose one of the platforms presented. Choose the best match. If your choice is not matched exactly, choose something anyway, complete the rest of this step, and go on to the following step.

Copy the environment variables which are printed out into your setup profile, such as \code{//home/username/.bashrc}, where \code{username} is your username. Replace all instances of \code{//home/username} with your actual username, like \code{//home/janedoe}.


\subsubsection{Environment variable explanations}
\label{1_0_installation:environment-variable-explanations}
An explanation of each variable appears in the next section

MAST\_INSTALL\_PATH: This variable should be set to the installation directory.

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\_INSTALL\_PATH=//share/apps/MAST
\end{Verbatim}

MAST\_RECIPE\_PATH: MAST looks for recipe templates in this folder. You may want to copy recipes from the \code{\$MAST\_INSTALL\_PATH/recipe\_templates} directory into this folder and modify them.

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\_RECIPE\_PATH=//home/username/MAST/recipe\_templates
\end{Verbatim}

MAST\_SCRATCH: This variable may be set to any directory. MAST will look for recipes in this directory.

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\_SCRATCH=//home/username/MAST/SCRATCH
\end{Verbatim}

MAST\_ARCHIVE: This variable may be set to any directory. MAST will move completed recipes from \code{\$MAST\_SCRATCH} into this directory.

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\_ARCHIVE=//home/username/MAST/ARCHIVE
\end{Verbatim}

MAST\_CONTROL: This variable may be set to any directory. MAST monitor log files, MAST monitor error files, and other MAST monitor output will be written to this directory.

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\_CONTROL=//home/username/MAST/CONTROL
\end{Verbatim}

PYTHONPATH: If this environment variable already exists, the MAST installation directory should be appended. Otherwise, this variable can be set to the installation directory. Assuming PYTHONPATH already has some value (use env to see a list of environment variables):

\begin{Verbatim}[commandchars=\\\{\}]
export PYTHONPATH=\$PYTHONPATH://share/apps/MAST
\end{Verbatim}

VASP\_PSP\_DIR: This variable is necessary if VASP and VASP pseudopotential files are being used. See the documentation for the \href{http://materialsproject.org}{Materials Project's} \href{http://pymatgen.org}{pymatgen} code. The VASP\_PSP\_DIR should be set to a path which contains folder such as POT\_GGA\_PAW\_PBE (for functional PBE, or mast\_xc PBE in Ingredients) or POT\_GGA\_PAW\_PW91 (for functional PW91).

\begin{Verbatim}[commandchars=\\\{\}]
export VASP\_PSP\_DIR=//share/apps/MAST/vasp\_pps
\end{Verbatim}

PATH: This variable should be appended with the \code{\$MAST\_INSTALL\_PATH/bin} directory, for example:

\begin{Verbatim}[commandchars=\\\{\}]
export PATH=\$PATH://share/apps/MAST/bin:PATH
\end{Verbatim}


\subsection{Modify submission details for your platform}
\label{1_0_installation:modify-submission-details-for-your-platform}
If your platform was not matched exactly, you should go to \code{\$MAST\_INSTALL\_PATH/submit/platforms}.

Copy the closest-matching set of files into a new directory inside the \code{platforms} folder.
Then, modify each of the following files as necessary for your platform:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{submit\PYGZus{}template}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{mastmon\PYGZus{}submit}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{queue\PYGZus{}commands}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

Go to \$MAST\_INSTALL\_PATH and again run

\begin{Verbatim}[commandchars=\\\{\}]
python initialize.py
\end{Verbatim}

This time, select your new platform.


\subsubsection{mastmon\_submit.sh}
\label{1_0_installation:mastmon-submit-sh}
This submission script is responsible for submitting to the ingredient- and recipe-checking script to the queue every time \code{mast} is called.

It should be set up to run on the shortest-wallclock, fastest-turnaround queue on your system (e.g. a serial queue, morganshort, etc.)

The script is copied into the \$MAST\_CONTROL directory by the \code{initialize.py} script and will be run from there.

Test mastmon\_submit.sh by submitting it to the queue. A ``mastmon'' process should briefly appear on the queue. Continue to modify submit.sh until the ``mastmon'' process successfully runs on the queue.

Use commands similar to these (\code{sbatch} instead of \code{qsub} for slurm):

\begin{Verbatim}[commandchars=\\\{\}]
cd \$MAST\_CONTROL
qsub mastmon\_submit.sh
\end{Verbatim}


\subsubsection{submit\_template.sh}
\label{1_0_installation:submit-template-sh}
This submission script template will be used to build submission scripts for the ingredients. Use \code{?mast\_keyword?} to denote a place where the following MAST keywords (see {\hyperref[3_0_inputfile::doc]{\emph{Input File}}} for more information on keywords) may be substituted in.
\begin{itemize}
\item {} 
mast\_processors or a combination of mast\_ppn and mast\_nodes

\item {} 
mast\_queue

\item {} 
mast\_exec

\item {} 
mast\_walltime

\item {} 
mast\_memory

\item {} 
the ingredient name

\end{itemize}

Examine the template carefully, as an error here will prevent your ingredients from running successfully on the queue.


\subsubsection{queue\_commands.py}
\label{1_0_installation:queue-commands-py}
These queue commands will be used to submit ingredients to the queue.


\subsection{Additional setup}
\label{1_0_installation:additional-setup}
Figure out the correct mast\_exec calls for your system, to be used in the {\hyperref[3_0_inputfile::doc]{\emph{Input File}}}. Examples are below.
\begin{itemize}
\item {} 
Bardeen: \code{mast\_exec //opt/mpiexec/bin/mpiexec //share/apps/bin/vasp5.2\_par\_opt1}  (or any of the other vasp executables)

\item {} 
DLX: \code{mast\_exec //home/username/bin/vaspmpirun}, where vaspmpirun is the following script (indentations are all part of the previous line):

\begin{Verbatim}[commandchars=\\\{\}]
\#!/bin/bash
export PERL5LIB=/opt/moab/lib/perl5
export MIC\_LD\_LIBRARY\_PATH=/share/cluster/RHEL6.2/x86\_64/
    apps/intel/ict/composer\_xe\_2013.0.079/compiler/lib/mic
export LD\_LIBRARY\_PATH=/share/cluster/RHEL6.2/x86\_64/apps/
    openmpi/1.6.2/lib:
    /share/cluster/RHEL6.2/x86\_64/apps/intel/ict/
    composer\_xe\_2013.0.079/compiler/lib/intel64:
    /share/cluster/RHEL6.2/x86\_64/apps/intel/ict/
    composer\_xe\_2013.0.079/mkl/lib/intel64
export INTEL\_MKL\_LIBS=/share/cluster/RHEL6.2/x86\_64/
    apps/intel/ict/composer\_xe\_2013.0.079/mkl/lib/intel64
export QTLIB=/usr/lib64/qt-3.3/lib
PATH=\$PATH:\$HOME/bin:\$HOME/bin/convaspTest
export PATH
VaspPath=//home/adozier/VASP/vasp.5.2
export OMP\_NUM\_THREADS=1
ulimit -s unlimited
ulimit -l unlimited
\#mpirun \$VaspPath/vasp
//share/cluster/RHEL6.2/x86\_64/apps/openmpi/1.6.2/bin/
    mpirun \$VaspPath/vasp
\end{Verbatim}

\end{itemize}

Modify \textasciitilde{}/.bashrc if necessary
\begin{itemize}
\item {} 
ACI/HPC, add: \code{export LD\_LIBRARY\_PATH=\$LD\_LIBRARY\_PATH://opt/intel/lib/intel64}

\end{itemize}

To ensure recipes are created correctly, add python whitespace tab stops to your \textasciitilde{}/.vimrc file:

\begin{Verbatim}[commandchars=\\\{\}]
" VIM settings for python in a group below:
set tabstop=4
set shiftwidth=4
set smarttab
set expandtab
set softtabstop=4
set autoindent
\end{Verbatim}

Follow the testing instructions from {\hyperref[1_0_installation:test-on-cluster]{\emph{Test that MAST can run}}}


\section{Test that MAST can run}
\label{1_0_installation:test-that-mast-can-run}\label{1_0_installation:test-on-cluster}\begin{enumerate}
\item {} 
Make a test directory, like \code{//home/username/MAST/test}

\item {} 
Copy the test input file to your test folder (all one line):

\begin{Verbatim}[commandchars=\\\{\}]
cp //share/apps/MAST/test/phononreorgtest/
phonon\_with\_neb.inp //home/username/MAST/test/test.inp
\end{Verbatim}

\item {} 
Go to your test directory, \code{cd //home/username/MAST/test}

\item {} 
Modify the test.inp file with the correct \code{mast\_exec}, \code{mast\_ppn}, \code{mast\_queue}, and other settings described in \emph{platforms}

\item {} 
Try to parse the input file, entering the following command as one line:

\begin{Verbatim}[commandchars=\\\{\}]
nice -n 19 mast -i test.inp
\end{Verbatim}
\begin{itemize}
\item {} 
The .nice -n 19. keeps this command low priority, since it is being run on the headnode (but it is not too intensive).

\item {} 
The -i signals to MAST that it is processing an input file.

\end{itemize}

\item {} 
Your \code{//home/username/MAST/SCRATCH} directory should now have a folder with a very long name in it (recipe directory), which contains several subfolders (ingredient directories).

\item {} 
Go to that long recipe directory. (PhononNebTest...)
\begin{itemize}
\item {} 
To see the input options:
\begin{itemize}
\item {} 
\code{cat input.inp} (should be identical to test.inp since no looping was used)
\begin{itemize}
\item {} 
Note that you can use other viewing commands, not just .cat., but be careful not to edit any of these files.

\end{itemize}

\item {} 
\code{cat archive\_input\_options.txt} (should show Al instead of element X1)

\end{itemize}

\item {} 
To see information about the ingredient relationships MAST detected from the recipe template:
\begin{itemize}
\item {} 
\code{cat personal\_recipe.txt}

\item {} 
\code{cat archive\_recipe\_plan.txt}

\end{itemize}

\item {} 
To see ingredient statuses at a glance:
\begin{itemize}
\item {} 
\code{cat status.txt}

\end{itemize}

\end{itemize}

\item {} 
Run mast once: \code{nice -n 19 mast}

\item {} 
You should see a \emph{mastmon} job appear on morganshort.

\item {} 
MAST should have detected that the first ingredient was ready to run, so when that process disappears, run mast again: \code{nice -n 19 mast}

\item {} 
Now you should see \code{perfect\_opt1} appear on the queue.

\item {} 
\code{status.txt} in the recipe directory in \code{\$MAST\_SCRATCH} should show that \code{perfect\_opt1} is queued.

\item {} 
If you forgot some step above (like you forgot to create the submitlist file) and are running into strange problems, delete the PhononNebTest... folder from \code{\$MAST\_SCRATCH} and start again from the beginning of this section.

\item {} 
The \code{\$MAST\_CONTROL} folder gives you error messages and other information. See {\hyperref[5_0_runningmast::doc]{\emph{Running MAST}}} for tips.

\end{enumerate}


\section{Unit testing}
\label{1_0_installation:unit-testing}
To run unit tests and verify that the MAST code is sound, go to
\code{\$MAST\_INSTALL\_PATH/test} and run the command

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nosetests} \PYG{o}{-}\PYG{n}{v} \PYG{o}{-}\PYG{o}{-}\PYG{n}{nocapture}
\end{Verbatim}

Or, optionally, run the command

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nosetests} \PYG{o}{-}\PYG{n}{v} \PYG{o}{-}\PYG{o}{-}\PYG{n}{nocapture}
\end{Verbatim}

The \code{nocapture} option allows print statements.
The \code{verbose} option gives verbose results.

The development team may have designated some tests to be skipped. However, any errors should be reported to the development team.


\chapter{Ingredients}
\label{2_0_ingredients::doc}\label{2_0_ingredients:ingredients}
Each ingredient is a separate calculation. Ingredients make up recipes.

Each ingredient is responsible for updating its child ingredients through an update\_children method.

Each ingredient is given:
\begin{itemize}
\item {} 
A name, which is the full path to the ingredient.s directory and is automatically generated using the system name and the recipe template. (Do not use parentheses in ingredient names.) Some ingredient names must be structured specifically. For examples of naming conventions, see the {\hyperref[4_0_recipe::doc]{\emph{Recipe}}}. In particular:

\item {} 
An ingredient which is supposed to correspond to values given by the \code{\$defects} section of the {\hyperref[3_0_inputfile::doc]{\emph{Input File}}} should always be named with \code{inducedefect\_} (for the structural creation of the defect) or \code{defect\_} (for an actual defect calculation)

\item {} 
An ingredient which is supposed to correspond to values in the \code{\$neb} section, such as a nudged elastic band (NEB) calculation or the static image calculations of an NEB calculation, should always be named with \code{neb\_}

\item {} 
A phonon calculation should always be named with \code{phonon\_}, and a subsequent calculation of phonon results should be named with \code{phonon\_...parse}

\item {} 
The letters \textbf{q=} are reserved (generated automatically by the recipe template in some cases) and should not otherwise be put in an ingredient name

\item {} 
A dictionary of program-specific keywords, which come from each ingredient.s section in the \code{\$ingredients} section of the {\hyperref[3_0_inputfile::doc]{\emph{Input File}}}.

\item {} 
A pymatgen structure object representing the very first structure created from the \code{\$structure} section in the input file.

\item {} 
A type, which is specified in the recipe, next to the ingredient name, in parentheses. The ingredient type corresponds to the ingredient type subsection in the \code{\$ingredients} section of the input file. The information given in these subsections includes:
\begin{itemize}
\item {} 
Program-specific keywords

\item {} 
Other MAST keywords, including:
\begin{itemize}
\item {} 
The \textbf{write} method: which files the ingredient should write out before running (e.g., create the INCAR)

\item {} 
The \textbf{ready} method: how MAST can tell if the ingredient is ready to run (often, in addition to writing its own files, an ingredient must also wait for data from its parent ingredient(s)).

\item {} 
The \textbf{run} method: what MAST should do to run the ingredient (e.g. submit a submission script to a queue, or perform some other action)

\item {} 
The \textbf{complete} method: how MAST can tell if the ingredient is considered complete

\item {} 
The \textbf{update children} method: what information an ingredient passes on to its children, and how this information is passed on

\end{itemize}

\end{itemize}

\end{itemize}

The same ingredient in a recipe may be listed more than once, with several different ingredient types. In this case, the first four methods and all the ingredient keywords are given by the first ingredient type encountered. Only the .update\_children. method is changed for all subsequent positions. This situation indicates that the ingredient has many children, which must be updated in different ways and thus needs different update\_children methods for those different situations.

More detail on ingredients is given in the \code{\$ingredients} section of the {\hyperref[3_0_inputfile::doc]{\emph{Input File}}}.


\chapter{Input File}
\label{3_0_inputfile::doc}\label{3_0_inputfile:input-file}

\section{Introduction to the Input File}
\label{3_0_inputfile:introduction-to-the-input-file}
The MAST program is driven by two main files: an input file which contains all the various keywords required for setting up the recipe (i.e. workflow), and a {\hyperref[4_0_recipe::doc]{\emph{Recipe Template}}} which organizes all the ingredients (i.e. calculations) in the recipe. In this section, we will discuss the input file

The input file contains several sections and subsections.
Bounds of sections are denoted by \code{\$sectionname} and \code{\$end}.
Bounds of subsections within a section are denoted by \code{begin subsectionname} and \code{end}.

\emph{Comments in the input file are allowed only as separate lines starting with \#. A comment may not be appended to a line.}

Example of the \code{\$structure} section, with three subsections, \textbf{elementmap}, \textbf{coordinates}, and \textbf{lattice}:

\begin{Verbatim}[commandchars=\\\{\}]
\$structure
coord\_type fractional

begin elementmap
X1 Ga
X2 As
end

begin coordinates
X1 0.000000 0.000000 0.000000
X1 0.500000 0.500000 0.000000
X2 0.250000 0.250000 0.250000
X2 0.750000 0.750000 0.250000
end

begin lattice
6.0 0.0 0.0
0.0 6.0 0.0
0.0 0.0 6.0
end
\$end
\end{Verbatim}

Each section is described in detail below.


\section{The MAST section}
\label{3_0_inputfile:the-mast-section}
The \code{\$mast} section contains this keyword:
\begin{itemize}
\item {} 
system\_name: Specify a single descriptive word here, like EpitaxialStrain. This keyword will become part of the recipe directory.s name and allow you to spot the recipe in the \code{\$MAST\_SCRATCH} directory:

\begin{Verbatim}[commandchars=\\\{\}]
system\_name EpitaxialStrain
\end{Verbatim}

\end{itemize}


\section{The Structure section}
\label{3_0_inputfile:the-structure-section}
The \code{\$structure} section contains the coordinate type, coordinates, and lattice, or, optionally, the name of a structure file (either CIF or VASP POSCAR-type).


\subsection{Structure by file}
\label{3_0_inputfile:structure-by-file}
Using the keyword \code{posfile}, a VASP POSCAR-type file or a CIF file can be inserted here in this section:

\begin{Verbatim}[commandchars=\\\{\}]
\$structure
posfile POSCAR\_fcc
\$end
\end{Verbatim}

The file should be located in the same directory as the input file.

A CIF file should end with .cif.

A POSCAR-type filename must start with \code{POSCAR\_} or \code{CONTCAR\_} in order for pymatgen to recognize it. The elements will be obtained from the POSCAR unless you also have a POTCAR in the directory, in which case, check your output carefully because the elements might be given by the POTCAR instead, no matter what elements are written in the POSCAR file.


\subsection{Structure by specification}
\label{3_0_inputfile:structure-by-specification}
To specify a structure, use the following subsections:

\textbf{coord\_type}: This keyword specifies fractional or cartesian coordinates. Only fractional coordinates have been thoroughly tested with most MAST features.

\textbf{lattice}: The lattice subsection specifies lattice basis vectors on a cartesian coordinate system.

\textbf{elementmap}: The elementmap subsection allows you to create a generic lattice and interchange other elements onto it. This is useful when looping over other elements (discussed later).

The elementmap subsection works in conjunction with the coordinates subsection.

\textbf{coordinates}: The coordinates subsection specifies the coordinates in order.

Fractional coordinates are fractional along each lattice basis vector, e.g. .0.5 0 0. describes a position 0.5 (halfway) along the first lattice basis vector.

Each fractional coordinate must be preceded by either an element symbol or an X\# symbol corresponding to the symbols assigned in the elementmap section.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
begin \$structure

coord\_type fractional

begin lattice
6.0 0.0 0.0
0.0 6.0 0.0
0.0 0.0 6.0
end

begin elementmap
X1 Ga
X2 As
end

begin coordinates
X1 0.000000 0.000000 0.000000
X1 0.500000 0.500000 0.000000
X1 0.000000 0.500000 0.500000
X1 0.500000 0.000000 0.500000
X2 0.250000 0.250000 0.250000
X2 0.750000 0.750000 0.250000
X2 0.250000 0.750000 0.750000
X2 0.750000 0.250000 0.750000
end

\$end
\end{Verbatim}


\section{The Ingredients section}
\label{3_0_inputfile:the-ingredients-section}
The \code{\$ingredients} section contains a section for global ingredient keywords and then a section for each ingredient type.

Program-specific keywords such as VASP INCAR keywords are included in these sections. All other keywords are prefaced with \code{mast\_}.

Each ingredient type in the recipe should have a subsection denoted by

\begin{Verbatim}[commandchars=\\\{\}]
begin ingredient\_type
(keywords here)
end
\end{Verbatim}

even if there are no keywords within that section, in which case the \code{end} line directly follows the \code{begin} line.


\subsection{Ingredients that are VASP calculations}
\label{3_0_inputfile:ingredients-that-are-vasp-calculations}
VASP keywords such as \code{IBRION}, \code{ISIF}, \code{LCHARG}, \code{LWAVE}, and so on, can be specified under each ingredient type in the \code{\$ingredients} section of the input file.

Such program-specific keywords are only allowed if they are listed in the program-specific file located in the \code{\$MAST\_INSTALL\_PATH/MAST/ingredients/programkeys/} folder, for example, \code{\$MAST\_INSTALL\_PATH/MAST/ingredients/programkeys/vasp\_allowed\_keywords.py}.

These program-specific keywords will be turned into uppercase keywords. The values will not change case, and should be given in the case required by the program. For example, \code{lwave False} will be translated into \code{LWAVE False} in the VASP INCAR file.

One exception for VASP keywords is the \code{IMAGES} keyword, which signals a nudged elastic band run, and should instead be set in the \code{\$neb} section of the input file.

For VASP ingredients, please include

\begin{Verbatim}[commandchars=\\\{\}]
lcharg False
lwave False
\end{Verbatim}

in your ingredient global keywords in order to avoid writing the large VASP files CHGCAR and WAVECAR, unless you really need these files.

Any keyword that starts with \code{mast\_} is considered a special keyword utilized by MAST and will not be written into the VASP INCAR file.


\subsection{Special MAST ingredient keywords:}
\label{3_0_inputfile:special-mast-ingredient-keywords}
Some of these special MAST keywords are only appropriate for VASP calculations.

\textbf{mast\_program}: Specify which program to run (\code{vasp}, \code{vasp\_neb}, \code{phon}, or \code{None} for a generic program, are currently supported)

\begin{Verbatim}[commandchars=\\\{\}]
mast\_program vasp
\end{Verbatim}
\begin{itemize}
\item {} 
This keyword must be in lowercase

\end{itemize}

\textbf{mast\_kpoints}: Specify k-point instructions in the form of kpoints along lattice vectors a, b, and c, and then a designation M for Monkhorst-Pack or G for Gamma-centered.

mast\_kpoints = 3x3x3 G
\begin{itemize}
\item {} 
Either this keyword or \code{mast\_kpoint\_density} is required for VASP calculations.

\end{itemize}

\textbf{mast\_kpoint\_density}: A number for the desired kpoint mesh density.
\begin{itemize}
\item {} 
Only works with \code{mast\_write\_method} of \code{write\_singlerun\_automesh}

\item {} 
Either this keyword or \code{mast\_kpoints} is required for VASP calculations.

\end{itemize}

\textbf{mast\_pp\_setup}: Specify which pseudopotential goes to which element:

\begin{Verbatim}[commandchars=\\\{\}]
mast\_pp\_setup La=La Mn=Mn\_pv O=O\_s
\end{Verbatim}

\textbf{mast\_xc}: Specify an exchange correlation functional; for VASP, follow the conventions of pymatgen (e.g. pw91, pbe)
\begin{itemize}
\item {} 
This keyword is required for VASP calculations.

\end{itemize}

\textbf{mast\_multiplyencut}: Specify a number with which to multiply the maximum ENCUT value of the pseudopotentials. Volume relaxations in VASP often take 1.5; otherwise 1.25 is sufficient.
\begin{itemize}
\item {} 
Default is 1.5

\item {} 
If \code{encut} is given as a program keyword, then that value will be used and \code{mast\_multiplyencut} should have no effect

\end{itemize}

\textbf{mast\_setmagmom}: Specify a string to use for setting the initial magnetic moment. A short string will result in multipliers. For example, \code{mast\_setmagmom 1 5 1} will produce \code{2*1 2*5 8*1} for a 12-atom unit cell with 2A, 2B, and 8C atoms. A string of the number of atoms in the \code{POSCAR} file will be printed as entered, for example, \code{mast\_setmagmom 1 -1 1 -1 1 -1 1 -1}.

\textbf{mast\_charge}: Specify the charge on the system (total system)
\begin{itemize}
\item {} 
-1 charge means the ADDITION of one electron. For example, O2- has two more electrons than O neutral.

\item {} 
A positive charge is the REMOVAL of electrons. For example, Na+ with a +1 charge has one FEWER electron than Na neutral.

\end{itemize}

\textbf{mast\_coordinates}: For a non-NEB calculation, allows you to specify a single POSCAR-type of CIF structure file which corresponds to the relaxed fractional coordinates at which you would like to start this ingredient. ONLY the coordinates are used. The lattice parameters and elements are given by the \$structure section of the input file. The coordinates must be fractional coordinates.

\begin{Verbatim}[commandchars=\\\{\}]
mast\_coordinates POSCAR\_initialize
\end{Verbatim}
\begin{itemize}
\item {} 
For an NEB calculation, use a comma-delimited list of poscar files corresponding to the correct number of images. Put no spaces between the file names. Example for an NEB with 3 intermediate images:

\begin{Verbatim}[commandchars=\\\{\}]
mast\_coordinates POSCAR\_im1,POSCAR\_im2,POSCAR\_im3
\end{Verbatim}

\item {} 
The structure files must be found in the directory from which the input file is being submitted when initially inputting the input file (e.g. the directory you are in when you run \code{mast -i test.inp}); once the \code{input.inp} file is created in the recipe directory, it will store a full path back to these poscar-type files.

\item {} 
This keyword cannot be used with programs other than VASP, cartesian coordinates, and special ingredients like inducedefect-type ingredients, whose write or run methods are different.

\end{itemize}

\textbf{mast\_strain}: Specify three numbers for multiplying the lattice parameters a, b, and c. Only works with \code{mast\_run\_method} of \code{run\_strain}

\begin{Verbatim}[commandchars=\\\{\}]
mast\_strain 1.01 1.03 0.98
\end{Verbatim}

This example will stretch the lattice along lattice vector a by 1\%, stretch the lattice along lattice vector b by 3\%, and compress the lattice along lattice vector c by 2\%

\textbf{mast\_scale}: A number for which to scale all dimensions of a supercell. Only works with \code{mast\_run\_method} of \code{run\_scale} or \code{run\_scale\_defect}

\textbf{mast\_frozen\_seconds}: A number of seconds before a job is considered frozen, if its output file has not been updated within this amount of time. If not set, 21000 seconds is used.

\textbf{mast\_auto\_correct}: Specify whether mast should automatically correct errors.
\begin{itemize}
\item {} 
The default is True, so if this keyword is set to True, or if this keyword is not specified at all, then MAST will attempt to find errors, automatically correct the errors, and resubmit the ingredient.

\item {} 
If set to False, MAST will attempt to find errors, then write them into a \code{MAST\_ERROR} file in the recipe folder, logging both the error-containing ingredient and the nature of the error, but not taking any corrective actions. The recipe will be skipped in all subsequent MAST runs until the \code{MAST\_ERROR} file is manually deleted by the user.

\end{itemize}

The following keyword is used only for generic programs (not VASP, PHON, or any other named programs).

\textbf{mast\_started\_file}: A file name in the ingredient directory whose presence signals that the ingredient run has been started.

\begin{Verbatim}[commandchars=\\\{\}]
mast\_started\_file        GAoutput.txt
\end{Verbatim}

The following queue-submission keywords are platform dependent and are used along to create the submission script:

\textbf{mast\_exec}: The command used in the submission script to execute the program. Note that this is a specific command rather than the .class. of program, given in \code{mast\_program}, and it should include any MPI commands.

\begin{Verbatim}[commandchars=\\\{\}]
mast\_exec //opt/mpiexec/bin/mpiexec \textasciitilde{}/bin/vasp\_5.2
\end{Verbatim}

\textbf{mast\_nodes}: The number of nodes requested.

\textbf{mast\_ppn}: The number of processors per node requested.

\textbf{mast\_queue}: The queue requested.

\textbf{mast\_walltime}: The walltime requested, in whole number of hours

\textbf{mast\_memory}: The memory per processor requested.

The following keywords have individual sections:

\textbf{mast\_write\_method}: The .write. method, which specifies files the ingredient should write out before running (e.g., create the INCAR)

\textbf{mast\_ready\_method}: The .ready. method, which specifies how MAST can tell if the ingredient is ready to run (often, in addition to writing its own files, an ingredient must also wait for data from its parent ingredient(s)).

\textbf{mast\_run\_method}: The .run. method, which specifies what MAST should do to run the ingredient (e.g. submit a submission script to a queue, or perform some other action)

\textbf{mast\_complete\_method}: The .complete. method, which specifies how MAST can tell if the ingredient is considered complete

\textbf{mast\_update\_children\_method}: the .update children. method, which specifies what information an ingredient passes on to its children, and how it does so.


\subsubsection{Important notes on using mast\_xxx\_method keywords}
\label{3_0_inputfile:important-notes-on-using-mast-xxx-method-keywords}\label{3_0_inputfile:important-notes}
Specific available values for each keyword are given in the accompanying sections, and require no arguments, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
mast\_write\_method write\_singlerun
\end{Verbatim}

However, you may choose to specify arguments where available, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
mast\_complete\_method file\_has\_string myoutput "End of Execution"
\end{Verbatim}

You may also choose to specify multiple methods. These methods will be performed in the order listed. For \code{mast\_ready\_method} or \code{mast\_complete\_method}, all methods listed must return True in order for the ingredient to be considered ready or complete, respectively.
Use a semicolon to separate out the methods:

\begin{Verbatim}[commandchars=\\\{\}]
mast\_complete\_method file\_has\_string myoutput "End of Execution"; file\_exists Parsed\_Structures
\end{Verbatim}

In the example above, the file ``myoutput'' must exist and contain the phrase ``End of Execution'', and the file ``Parsed\_Structures'' must exist, in order for the ingredient to be considered complete.

Update-children methods will always get the child name appended as the end of the argument string. For example,

\begin{Verbatim}[commandchars=\\\{\}]
mast\_update\_children\_method copy\_file EndStructure BeginStructure
\end{Verbatim}

will copy the file EndStructure of the parent ingredient folder to a new file BeginStructure in the child ingredient folder. There is no separate argument denoting the child ingredient.

All arguments are passed as strings. Arguments in quotation marks are kept together.

Some common open-ended methods are:
\begin{itemize}
\item {} 
\textbf{file\_exists \textless{}filename\textgreater{}}

\item {} 
\textbf{file\_has\_string \textless{}filename\textgreater{} \textless{}string\textgreater{}}

\item {} 
\textbf{copy\_file \textless{}filename\textgreater{} \textless{}copy\_to\_filename\textgreater{}}

\item {} 
\textbf{softlink\_file \textless{}filename\textgreater{} \textless{}softlink\_to\_filename\textgreater{}}

\item {} 
\textbf{copy\_fullpath\_file \textless{}full path file name\textgreater{} \textless{}copy\_to\_filename\textgreater{}}: This method is for copying some system file like //home/user/some\_template, not an ingredient-specific file

\item {} 
\textbf{write\_ingred\_input\_file \textless{}filename\textgreater{} \textless{}allowed file\textgreater{} \textless{}uppercase keywords\textgreater{} \textless{}delimiter\textgreater{}}: The allowed file specifies an allowed keywords file name in \code{\$MAST\_INSTALL\_PATH/MAST/ingredients/programkeys}.
\begin{itemize}
\item {} 
Use ``all'' to put any non-mast keywords into the input file.

\item {} 
Use 1 to uppercase all keywords, or 0 to leave them as entered.

\item {} 
Leave off the delimiter argument in order to use a single space.

\item {} 
Examples:

\begin{Verbatim}[commandchars=\\\{\}]
write\_ingred\_input\_file input.txt all 0 =
write\_ingred\_input\_file input.txt phon\_allowed\_keys.py 1
\end{Verbatim}

\end{itemize}

\item {} 
\textbf{no\_setup}: Does nothing. Useful when you want to specifically specify doing nothing.

\item {} 
\textbf{no\_update}: Does nothing (but, does accept the child name it is given). Useful when you want to specify doing nothing for a child update step.

\item {} 
\textbf{run\_command: \textless{}command string, including all arguments\textgreater{}}: This method allows you to run a python script.
\begin{itemize}
\item {} 
The python script may take in only string-based arguments

\item {} 
Please stick to common text characters.

\item {} 
Example:

\begin{Verbatim}[commandchars=\\\{\}]
mast\_run\_method run\_command "//home/user/myscripts/my\_custom\_parsing.py 25 0.01"
\end{Verbatim}

\item {} 
In the example above, the numbers 25 and 0.01 will actually be passed into sys.argv as a string.

\item {} 
This method is intended to allow you to run short custom scripts of your own creation, particularly for \code{mast\_write\_method} when setting up your ingredient.

\item {} \begin{description}
\item[{For long or complex execution steps where you want the output tracked separately, do not use this method. Instead, do the following in order to get your script submitted to the queue:}] \leavevmode
\#  Use \code{write\_submit\_script} in your \code{mast\_write\_method}, along with any other write methods
\#  Use \code{mast\_run\_method run\_singlerun}
\#  Put your script in the \code{mast\_exec} keyword
*  Some useful scripts are found in \code{\$MAST\_INSTALL\_PATH/tools} and described in {\hyperref[6_0_tools:tools]{\emph{MAST post-processing utilities}}}

\end{description}

\end{itemize}

\end{itemize}


\subsubsection{mast\_write\_method keyword values}
\label{3_0_inputfile:mast-write-method-keyword-values}
\textbf{write\_singlerun}
\begin{itemize}
\item {} 
Write files for a single generic run.

\item {} 
Programs supported: vasp, phon (phon assumes vasp-type output given by one of the .give\_phonon. update children methods)

\end{itemize}

\textbf{write\_singlerun\_automesh}
\begin{itemize}
\item {} 
Write files for a single generic run.

\item {} 
Programs supported: vasp

\item {} 
Requires the \code{mast\_kpoint\_density} ingredient keyword

\end{itemize}

\textbf{write\_neb}
\begin{itemize}
\item {} 
Write an NEB ingredient. This method writes interpolated images to the appropriate folders, creating 00/01/.../0N directories.

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{write\_neb\_subfolders}
\begin{itemize}
\item {} 
Write static runs for an NEB, starting from a previous NEB, into image subfolders 01 to 0(N-1).

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{write\_phonon\_single}
\begin{itemize}
\item {} 
Write files for a phonon run.

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{write\_phonon\_multiple}
\begin{itemize}
\item {} 
Write a phonon run, where the frequency calculation for each atom and each direction is a separate run, using selective dynamics. CHGCAR and WAVECAR must have been given to the ingredient previously; these files will be softlinked into each subfolder.

\item {} 
Programs supported: vasp

\end{itemize}


\subsubsection{mast\_ready\_method keyword values}
\label{3_0_inputfile:mast-ready-method-keyword-values}
\textbf{ready\_singlerun}
\begin{itemize}
\item {} 
Checks that a single run is ready to run

\item {} 
Programs supported: vasp (either NEB or regular VASP run), phon

\end{itemize}

\textbf{ready\_defect}
\begin{itemize}
\item {} 
Checks that the ingredient has a structure file

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{ready\_neb\_subfolders}
\begin{itemize}
\item {} 
Checks that each 01/.../0(N-1) subfolder is ready to run as its own separate calculation, following the ready\_singlerun criteria for each folder

\item {} 
This method is used for NEB static calculations rather than NEB calculations themselves.

\end{itemize}

\textbf{ready\_subfolders}
*  Checks that each subfolder is ready to run, following the ready\_singlerun criteria.
*  Generic
*  This method is used for calculations whose write method includes subfolders, and where each subfolder is a calculation, as in \code{write\_phonon\_multiple}.


\subsubsection{mast\_run\_method keyword values}
\label{3_0_inputfile:mast-run-method-keyword-values}
\textbf{run\_defect}
\begin{itemize}
\item {} 
Create a defect in the structure; not submitted to queue

\item {} 
Generic

\item {} 
Requires the \code{\$defects} section in the input file.

\end{itemize}

\textbf{run\_singlerun}
\begin{itemize}
\item {} 
Submit a run to the queue.

\item {} 
Generic

\end{itemize}

\textbf{run\_neb\_subfolders}
\begin{itemize}
\item {} 
Run each 01/.../0(N-1) subfolder as run\_singlerun

\item {} 
Generic

\end{itemize}

\textbf{run\_subfolders}
\begin{itemize}
\item {} 
Run each subfolder as run\_singlerun

\item {} 
Generic

\end{itemize}

\textbf{run\_strain}
\begin{itemize}
\item {} 
Strain the structure; not submitted to queue

\item {} 
Generic

\item {} 
Requires the \code{mast\_strain} ingredient keyword

\end{itemize}

\textbf{run\_scale}
\begin{itemize}
\item {} 
Scale the structure (e.g. a 2-atom unit cell scaled by 2 becomes a 16-atom supercell)

\item {} 
Generic

\item {} 
Requires the \code{mast\_scale} ingredient keyword, and must not be run on the starting ingredient (for VASP, the ingredient must already have been given a smaller POSCAR file, like the POSCAR for a 2-atom unit cell)

\end{itemize}

\textbf{run\_scale\_defect}
\begin{itemize}
\item {} 
Scale the structure and defect it (e.g. a single defect at 0.5 0.5 0.5 in the original structure becomes a single defect at 0.25 0.25 0.25 in the structure scaled by 2)

\item {} 
Generic

\item {} 
Requires the \code{mast\_scale} ingredient keyword, and must not be run on the starting ingredient

\end{itemize}


\subsubsection{mast\_complete\_method keyword values}
\label{3_0_inputfile:mast-complete-method-keyword-values}
\textbf{complete\_singlerun}
\begin{itemize}
\item {} 
Check if run is complete

\item {} 
Programs supported: vasp, phon (only entropy calculation)

\item {} 
Note that for VASP, the phrase \code{reached required accuracy} is checked for, as well as a \code{User time} in seconds. The exceptions are:
\begin{itemize}
\item {} 
NSW of 0, NSW of -1, or NSW not specified in the ingredients section keywords is taken as a static calculation, and .EDIFF is reached. is checked instead of .reached required accuracy.

\item {} 
IBRION of -1 is taken as a static calculation, and .EDIFF is  reached. is checked instead of .reached required accuracy.

\item {} 
IBRION of 0 is taken as an MD calculation, and only user time is checked

\item {} 
IBRION of 5, 6, 7, or 8 is taken as a phonon calculation, and only user time is checked

\end{itemize}

\end{itemize}

\textbf{complete\_neb\_subfolders}
\begin{itemize}
\item {} 
Check if all NEB subfolders 01/.../0(N-1) are complete, according to complete\_singlerun criteria.

\item {} 
This method is not for checking the completion of NEBs! An NEB ingredient should have \code{mast\_program vasp\_neb} and \code{mast\_complete\_method complete\_singlerun}.

\item {} 
An NEB static calculation, or a static calculation for each image, would use this keyword as \code{mast\_complete\_method complete\_neb\_subfolders} but have \code{mast\_program vasp} instead of vasp\_neb.

\end{itemize}

\textbf{complete\_subfolders}
\begin{itemize}
\item {} 
Check if all subfolders are complete, according to complete\_singlerun criteria.

\item {} 
Generic

\end{itemize}

\textbf{complete\_structure}
\begin{itemize}
\item {} 
Check if run has an output structure file written

\item {} 
Programs supported: vasp (looks for CONTCAR)

\end{itemize}


\subsubsection{mast\_update\_children\_method keyword values}
\label{3_0_inputfile:mast-update-children-method-keyword-values}
\textbf{give\_structure}
\begin{itemize}
\item {} 
Forward the relaxed structure

\item {} 
Programs supported: vasp (CONTCAR to POSCAR)

\end{itemize}

\textbf{give\_structure\_and\_energy\_to\_neb}
\begin{itemize}
\item {} 
Forward the relaxed structure and energy files

\item {} 
Programs supported: vasp (CONTCAR to POSCAR, and copy over OSZICAR)

\end{itemize}

\textbf{give\_neb\_structures\_to\_neb}
\begin{itemize}
\item {} 
Give NEB output images structures as the starting point image input structures in another NEB

\item {} 
Programs supported: vasp (01/.../0(N-1) CONTCAR files will be the child NEB ingredient.s starting 01/.../0(N-1) POSCAR files.

\end{itemize}

\textbf{give\_phonon\_single\_forces\_and\_displacements(self, childname)}
\begin{itemize}
\item {} 
Forward force and displacement information

\item {} 
Programs supported: vasp, for vasp-to-phon transition (DYNMAT, XDATCAR)

\end{itemize}

\textbf{give\_phonon\_multiple\_forces\_and\_displacements}
\begin{itemize}
\item {} 
Combine individual phonon forces and displacements and forward this information

\item {} 
Programs supported: vasp, for vasp-to-phon transition (DYNMAT, XDATCAR)

\end{itemize}

\textbf{give\_saddle\_structure}
\begin{itemize}
\item {} 
Forward the highest-energy structure of all subfolder structures

\item {} 
Programs supported: vasp

\end{itemize}

The following keywords are deprecated. Please use the generic methods in {\hyperref[3_0_inputfile:important-notes]{\emph{Important notes on using mast\_xxx\_method keywords}}} instead.

give\_structure\_and\_restart\_files (same as give\_structure\_and\_restart\_files\_softlinks)
\begin{itemize}
\item {} 
Forward the relaxed structure and additional files

\item {} 
Programs supported: vasp (CONTCAR to POSCAR, and softlinks to parent.s WAVECAR and CHGCAR files)

\end{itemize}

give\_structure\_and\_restart\_files\_full\_copies
\begin{itemize}
\item {} 
Forward the relaxed structure and additional files

\item {} 
Programs supported: vasp (CONTCAR to POSCAR, and full copies of parent.s WAVECAR and CHGCAR files)

\end{itemize}

give\_structure\_and\_charge\_density\_full\_copy
\begin{itemize}
\item {} 
Forward the relaxed structure and charge density file; copies the file

\item {} 
Programs supported: vasp (CONTCAR to POSCAR, and copy over CHGCAR)

\end{itemize}

give\_structure\_and\_charge\_density\_softlink
\begin{itemize}
\item {} 
Forward the relaxed structure and charge density file as a softlink

\item {} 
Programs supported: vasp (CONTCAR to POSCAR, and softlink to CHGCAR)

\end{itemize}

give\_structure\_and\_wavefunction\_full\_copy
*  Forward the relaxed structure and wavefunction file; copies the file
*  Programs supported: vasp (CONTCAR to POSCAR, and copy over WAVECAR)

give\_structure\_and\_wavefunction\_softlink
\begin{itemize}
\item {} 
Forward the relaxed structure and wavefunction file as a softlink

\item {} 
Programs supported: vasp (CONTCAR to POSCAR, and softlink to WAVECAR)

\end{itemize}


\subsubsection{Custom mast\_xxx\_method keywords}
\label{3_0_inputfile:custom-mast-xxx-method-keywords}
You may also choose to write your own methods, in addition to any of the methods above.

Place these methods in a file in the directory \code{\$MAST\_INSTALL\_PATH/customlib}, structured like the file \code{\$MAST\_INSTALL\_PATH/customlib/customchopingredient.py}
\begin{itemize}
\item {} 
Please inherit from either ChopIngredient or BaseIngredient.

\item {} 
Name the method(s) something unique (e.g. not found in either ChopIngredient or BaseIngredient)

\item {} 
You will have access to the ingredient directory name at \code{self.keywords{[}'name'{]}} as well as ingredient keywords at \code{self.keywords{[}'program\_keys'{]}}.

\item {} 
The method may also take in up to 3 string-based arguments.

\item {} 
In the input file, designate your custom method as classname.methodname followed by any arguments, for example, \code{mast\_write\_method MyChopClass.write\_complex\_file superfile}

\end{itemize}


\subsubsection{Example Ingredients section}
\label{3_0_inputfile:example-ingredients-section}
Here is an example ingredients section:

\begin{Verbatim}[commandchars=\\\{\}]
\$ingredients
begin ingredients\_global
mast\_program    vasp
mast\_nodes      1
mast\_multiplyencut 1.5
mast\_ppn        1
mast\_queue      default
mast\_exec       mpiexec //home/mayeshiba/bin/vasp.5.3.3\_vtst\_static
mast\_kpoints    2x2x2 M
mast\_xc PW91
isif 2
ibrion 2
nsw 191
ismear 1
sigma 0.2
lwave False
lcharg False
prec Accurate
mast\_program   vasp
mast\_write\_method           write\_singlerun
mast\_ready\_method           ready\_singlerun
mast\_run\_method             run\_singlerun
mast\_complete\_method        complete\_singlerun
mast\_update\_children\_method  give\_structure
end

begin volrelax\_to\_singlerun
isif 3
end

begin singlerun\_to\_phonon
ibrion -1
nsw 0
mast\_update\_children\_method  give\_structure\_and\_restart\_files
mast\_multiplyencut 1.25
lwave True
lcharge True
end

begin inducedefect
mast\_write\_method           no\_setup
mast\_ready\_method           ready\_defect
mast\_run\_method             run\_defect
mast\_complete\_method        complete\_structure
end

begin singlerun\_vac1
mast\_coordinates            POSCAR\_vac1
end

begin singlerun\_vac2
mast\_coordinates            POSCAR\_vac2
end

begin singlerun\_to\_neb
ibrion -1
nsw 0
mast\_update\_children\_method  give\_structure\_and\_energy\_to\_neb
lwave True
lcharge True
end

begin neb\_to\_neb\_vac1-vac2
mast\_coordinates            POSCAR\_nebim1,POSCAR\_nebim2,POSCAR\_nebim3
mast\_write\_method           write\_neb
mast\_update\_children\_method  give\_neb\_structures\_to\_neb
mast\_nodes                  3
mast\_kpoints                1x1x1 G
ibrion 1
potim 0.5
images 3
lclimb True
spring -5
end

begin neb\_to\_neb\_vac1-vac3
mast\_coordinates            POSCAR\_nebim1\_set2,POSCAR\_nebim2\_set2,POSCAR\_nebim3\_set2
mast\_write\_method           write\_neb
mast\_update\_children\_method  give\_neb\_structures\_to\_neb
mast\_nodes                  3
mast\_kpoints                1x1x1 G
ibrion 1
potim 0.5
images 3
lclimb True
spring -5
end

begin neb\_to\_nebstat
mast\_write\_method           write\_neb
mast\_update\_children\_method  give\_neb\_structures\_to\_neb
mast\_nodes                  3
ibrion 1
potim 0.5
images 3
lclimb True
spring -5
end

begin nebstat\_to\_nebphonon
ibrion -1
nsw 0
mast\_write\_method           write\_neb\_subfolders
mast\_ready\_method           ready\_neb\_subfolders
mast\_run\_method             run\_neb\_subfolders
mast\_complete\_method        complete\_neb\_subfolders
mast\_update\_children\_method  give\_saddle\_structure
end

begin phonon\_to\_phononparse
mast\_write\_method           write\_phonon\_multiple
mast\_ready\_method           ready\_subfolders
mast\_run\_method             run\_subfolders
mast\_complete\_method        complete\_subfolders
mast\_update\_children\_method  give\_phonon\_multiple\_forces\_and\_displacements
ibrion 5
nfree 2
potim 0.01
istart 1
icharg 1
end

begin phononparse
mast\_program                phon
lfree .True.
temperature 273
ptemp 10 110
nd 3
qa 11
qb 11
qc 11
lnosym .True.
ldrift .False.
lsuper .False.
mast\_exec \$MAST\_INSTALL\_PATH/bin/phon\_henry
mast\_multiplyencut 1.25
end

\$end
\end{Verbatim}


\section{The Recipe section}
\label{3_0_inputfile:the-recipe-section}
The \code{\$recipe} section contains the recipe template to be used.

\begin{Verbatim}[commandchars=\\\{\}]
\$recipe
recipe\_file myrecipefile.txt
\$end
\end{Verbatim}


\section{The Defects section (optional)}
\label{3_0_inputfile:the-defects-section-optional}
The \code{\$defects} section includes the defect type of vacancy, interstitial, substitution, or antisite (which is the same as substitution), the defect coordinates, and the defect element symbol.
\begin{itemize}
\item {} 
Note that if an \code{elementmap} subsection is given in the \code{\$structure} section of the input file, the mapped designations \code{X1}, \code{X2}, and so on can be given instead of an element symbol.

\end{itemize}

The \code{coord\_type} keyword specifies fractional or cartesian coordinates for the defects.

The \code{threshold} keyword specifies the absolute threshold for finding the defect coordinate, since relaxation of the perfect structure may result in changed coordinates.

Example \code{\$defects} section:

\begin{Verbatim}[commandchars=\\\{\}]
\$defects

coord\_type fractional
threshold 1e-4

vacancy 0 0 0 Mg
vacancy 0.5 0.5 0.5 Mg
interstitial 0.25 0.25 0 Mg
interstitial 0.25 0.75 0 Mg

\$end
\end{Verbatim}

The above section specifies 4 point defects (2 vacancies and 2 interstitials) to be applied separately and independently to the structure. When combined with the correct {\hyperref[4_0_recipe::doc]{\emph{recipe}}}, four separate ingredients, each containing one of the defects above, will be created.

Multiple point defects can be also grouped together as a combined defect within a .begin/end,. with a label after the .begin,. such as:

\begin{Verbatim}[commandchars=\\\{\}]
\$defects

coord\_type fractional
threshold 1e-4

begin doublevac
vacancy 0.0 0.0 0.0 Mg
vacancy 0.5 0.5 0.5 Mg
end

interstitial 0.25 0.25 0 Mg
interstitial 0.25 0.75 0 Mg

\$end
\end{Verbatim}

In this case, there will be three separate .defect. ingredients: one ingredient with two vacancies together (where the defect group is labeled .doublevac.), one interstitial, and another interstitial.

Charges can be specified as \code{charge=0,10}, where a comma denotes the lower and upper ranges for the charges.

Let's say we want a Mg vacancy with charges from 0 to 3 (0, 1, 2, and 3):

\begin{Verbatim}[commandchars=\\\{\}]
vacancy 0 0 0 Mg charge=0,3
\end{Verbatim}

Let.s say we want a dual Mg vacancy with a charge from 0 to 3 and labeled as \href{mailto:Vac@Mg}{Vac@Mg}\href{mailto:-Vac@Mg}{-Vac@Mg}:

\begin{Verbatim}[commandchars=\\\{\}]
begin Vac@Mg-Vac@Mg
vacancy 0.0 0.0 0.0 Mg
vacancy 0.5 0.5 0.5 Mg
charge=0,3
end
\end{Verbatim}

For a single defect, charges and labels can be given at the same time:

Let's say we have a Mg vacancy with charges between 0 and 3, and we wish to label it as \href{mailto:Vac@Mg}{Vac@Mg}:

\begin{Verbatim}[commandchars=\\\{\}]
vacancy 0.0 0.0 0.0 Mg charge=0,3 label=Vac@Mg
\end{Verbatim}

The charge and label keywords are interchangeable, i.e. we could also have typed:

\begin{Verbatim}[commandchars=\\\{\}]
vacancy 0 0 0 Mg label=Vac@Mg charge=0,3
\end{Verbatim}

If you use charges in the defects section like this, then you should use a {\hyperref[4_0_recipe::doc]{\emph{recipe}}} template with a free-form defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{} format.


\subsection{Phonons for defects}
\label{3_0_inputfile:phonons-for-defects}
Phonon calculations are described by a \emph{phonon center site} coordinate and a \emph{phonon center radius} in Angstroms. Atoms within the sphere specified by these two values will be included in phonon calculations.

For VASP, this inclusion takes the form of selective dynamics T T T for the atoms within the sphere, and F F F otherwise, in a phonon calculation (IBRION = 5, 6, 7, 8)

If the phonon center radius is 0, only the atom found at the phonon center site point will be considered.

To use phonons in the defects section, use the subsection keyword .phonon. followed by a label for the phonon, the fractional coordinates for the phonon center site, a float value for the phonon center radius, and an optional float value for the tolerance-matching threshold for matching the phonon center site (if this last value is not specified, 0.1 is used). Multiple separate phonon calculations may be obtained for each defect, for example:

\begin{Verbatim}[commandchars=\\\{\}]
begin int1
interstitial 0.25 0.25 0.25 X2
phonon host3 0.3 0.3 0.4 2.5 0.01
phonon solute 0.1 0.1 0.2 0.5
end
\end{Verbatim}

In the example above, \emph{host3} is the label for the phonon calculation where (0.3, 0.3, 0.4) is the coordinate for the phonon center site, and 2.5 Angstroms is the radius for the sphere inside which to consider atoms for the phonon calculation. Points within 0.01 of fractional coordinates will be considered for matching the phonon center site.

In the example above, \emph{solute} is the label for the phonon calculation bounded within a 0.5 Angstrom radius centered at (0.1, 0.1, 0.2) in fractional coordinates. As no threshold value was given, points within 0.1 (default) of fractional coordinates will be considered for matching the phonon center site.

The recipe template file for phonons may include either the explicit phonon labels and their charge and defect label, or \textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{} (defect label \_ charge label \_ phonon label).

Because phonons are cycled with the defects, a new parent loop must be provided for the phonons, for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}begin\PYGZcb{}
defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_stat (static)
    phonon\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{} (phonon)
        phonon\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{}\_parse (phononparse)
\PYGZob{}end\PYGZcb{}
\end{Verbatim}


\section{The chemical potentials section}
\label{3_0_inputfile:the-chemical-potentials-section}
The \$chemical\_potentials section lists chemical potentials, used for defect formation energy calculations using the defect formation energy tool.
Currently, chemical potentials must be set ahead of time. Each chemical potential set may be labeled.

\begin{Verbatim}[commandchars=\\\{\}]
\$chemical\_potentials

begin Ga rich
Ga -3.6080
As -6.0383
Bi -4.5650
end

begin As rich
Ga -4.2543
As -5.3920
Bi -4.5650
end

\$end
\end{Verbatim}


\section{The NEB section}
\label{3_0_inputfile:the-neb-section}
The \code{\$neb} section includes a list of nudged-elastic-band hops. Each neb hop should be a subsection labeled with the starting and ending .defect group. as specified in the \code{\$defects} section, and then also indicate the movement of elements, and their closest starting and ending positions. These explicit positions disambiguate between possible interpolations.
\begin{itemize}
\item {} 
Note that if an \code{elementmap} subsection is given in the \code{\$structure} section of the input file, the mapped designations \code{X1}, \code{X2}, and so on can be given instead of an element symbol.

\end{itemize}

Again, the \code{\$neb} section is tied to specific defect labels. The NEB ingredients must be able to find defects or defect groups with those labels.

The \code{images} keyword specifies the number of intermediate images, which must currently be the same in all NEBs in the recipe.

Phonons may be specified within each NEB grouping, as in the defects section. The presumed saddle point in an NEB is usually taken; use the \code{mast\_update\_children give\_saddle\_structure} to give that saddle point structure to the phonon calculation. If, in an NEB, the frequencies for the moving atom are desired for the phonon calculations, and if that atom is anticipated to pass from fractional coordinate 0 0 0 to fractional coordinate 0.5 0 0, then the phonon\_center\_site should be 0.25 0 0 (assuming a straight path), and the phonon\_center\_radius is probably about 1 Angstrom.

Example defect and NEB section together:

\begin{Verbatim}[commandchars=\\\{\}]
\$defects

coord\_type fractional
threshold 1e-4

vacancy 0.0 0.0 0.0 Mg label=vac1
vacancy 0.0 0.5 0.5 Mg label=vac2
interstitial 0.25 0.0 0.0 Al label=int1
interstitial 0.0 0.25 0.0 Al label=int2

\$end

\$neb

begin vac1-vac2
images 1
Mg, 0 0 0, 0 .5 0.5
end

begin int1-int2
Al, 0.25 0 0, 0 0.25 0
images 3
phonon movingatom 0.125 0.125 0.0 1.0
end

\$end
\end{Verbatim}


\section{Creating several input files at once: the looped input file}
\label{3_0_inputfile:creating-several-input-files-at-once-the-looped-input-file}
One input file may be able to spawn several nearly-identical input files, which differ in small ways.


\subsection{Independent loops}
\label{3_0_inputfile:independent-loops}
The special looping keyword \code{indeploop} may be used to signify a line which indicates that spawned input files should cycle through these values.

\begin{Verbatim}[commandchars=\\\{\}]
indeploop mast\_xc (pw91, pbe)
\end{Verbatim}

In this example, two input files will be created. One input file will contain the line \code{mast\_xc pw91}. The other input file will contain the line \code{mast\_xc pbe}.
\begin{itemize}
\item {} 
Any text within parentheses and separated by a comma will be looped.

\item {} 
Lines which normally include commas, like the \code{charge} line in the \code{\$defects} section, or the \code{mast\_coordinates} keyword for an NEB, may not be looped.

\item {} 
This keyword may only be used once on a line.

\end{itemize}

If there is more than one \code{indeploop} keyword in the input file, a combinatorial spawn of input files will be created.

For example, this excerpt would generate four input files: one with iron using pw91, one with iron using pbe, one with copper using pw91, and one with copper using pbe:

\begin{Verbatim}[commandchars=\\\{\}]
\$structure
begin elementmap
indeploop X1 (Fe, Cu)
end
...
\$end

\$ingredients
begin ingredients\_global
indeploop mast\_xc (pw91, pbe)
...
end
\$end
\end{Verbatim}


\subsection{Dependent, or pegged, loops}
\label{3_0_inputfile:dependent-or-pegged-loops}
Sometimes looped lines should really be looped together at the same time, rather than with each value looped over each other value.

For example, if you want to create a single input file, but signify that it should be copied into three input files, one for each element, but with different GGA+U U-values, you would use a pegged loop like this:

\begin{Verbatim}[commandchars=\\\{\}]
\$structure
begin elementmap
pegloop1 X1 (Es, Fm, Md)
end
...
\$end

\$ingredients
begin ingredients\_global
pegloop1 ldauu (5.3, 6.5, 8.0)
...
end
\$end
\end{Verbatim}

In this case, three input files will be created. In the first input file, Es will be paired with a U-value of 5.3. In the second input file, Fm will be paired with a U-value of 6.5. In the third input file, Md will be paired with a U-value of 8.0.

There are two pegged loops allowed, specified by \code{pegloop1} and \code{pegloop2}.

Each pegged loop and independent loop will be combinatorially combined. For example, if a separate line \code{indeploop mast\_xc (pw91, pbe)} were included in the \code{ingredients\_global} subsection above, then six input files would be created: one pw91 and one pbe input file for Es with +U 5.3, another pair for Fm, and another pair for Mn.

In the example below, four input files would be created, corresponding to four different lattices:
*  {[}(6.0,0.0,0.0),(0.0,6.0,0.0),(0.0,0.0,2.0){]}
*  {[}(6.0,0.0,0.0),(0.0,6.0,0.0),(0.0,0.0,3.0){]}
*  {[}(4.0,0.0,0.0),(0.0,4.0,0.0),(0.0,0.0,2.0){]}, and
*  {[}(4.0,0.0,0.0),(0.0,4.0,0.0),(0.0,0.0,3.0){]}

\begin{Verbatim}[commandchars=\\\{\}]
begin lattice
pegloop1 (6.0,4.0) 0.0 0.0
pegloop1 0.0 (6.0,4.0) 0.0
indeploop 0.0 0.0 (2.0,3.0)
end
\end{Verbatim}


\chapter{The Recipe}
\label{4_0_recipe:the-recipe}\label{4_0_recipe::doc}

\section{Introduction to the Recipe}
\label{4_0_recipe:introduction-to-the-recipe}
The recipe defines the relationships between ingredients, or which ingredients need to be run before which other ingredients.

Out-of-the-box recipes are stored in \code{\$MAST\_INSTALL\_PATH/recipe\_templates}. You may copy them into your \code{\$MAST\_RECIPE\_PATH} directory (see {\hyperref[1_0_installation::doc]{\emph{Installation}}}). If you create new recipes, they should also go in the  \code{\$MAST\_RECIPE\_PATH} directory

The full recipe name goes in the \code{\$recipe} section of the input file:

\begin{Verbatim}[commandchars=\\\{\}]
\$recipe
recipe\_file neb.txt
\end{Verbatim}

\$end


\section{The Recipe Template}
\label{4_0_recipe:the-recipe-template}
\textbf{Important: when creating or editing recipes, do not use the Tab key. Instead, use 4 spaces to indent.}

Also make sure that the recipe you are working with has not somehow been converted to tabs.

If you use vi as your code editor, consider adding the following settings to your \code{\textasciitilde{}/.vimrc file}, in order to use python four-space tab stops instead of the Tab character.:

\begin{Verbatim}[commandchars=\\\{\}]
set tabstop=4
set shiftwidth=4
set smarttab
set expandtab
set softtabstop=4
set autoindent
\end{Verbatim}


\subsection{Syntax}
\label{4_0_recipe:syntax}
Each indentation level marks a parent-child relationship.:

\begin{Verbatim}[commandchars=\\\{\}]
perfect\_opt1 (volrelax\_lowmesh)
    perfect\_opt2
        perfect\_opt3
\end{Verbatim}

The ingredient type of an ingredient is specified in parentheses after the ingredient.

The ingredient type should correspond to ingredient subsections within the \$ingredients section of the {\hyperref[3_0_inputfile::doc]{\emph{input file}}}. If no ingredient type is specified, the ingredient gets all default values from the ingredients\_global subsection.

In the recipe:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{perfect\PYGZus{}opt1} \PYG{p}{(}\PYG{n}{volrelax\PYGZus{}lowmesh}\PYG{p}{)}
\end{Verbatim}

In the input file:

\begin{Verbatim}[commandchars=\\\{\}]
\$ingredients

begin volrelax\_lowmesh
mast\_run\_method run\_singlerun
...
end

\$end
\end{Verbatim}

If the parent needs to update several children in different ways, create new trees where the originating parent is the same parent name, but with a different ingredient type.
*  Those different ingredient types should have different mast\_update\_children\_method keyword values in the input file.
*  Only the first ingredient type specified per parent, going from the top of the file to the bottom of the file, will be used for all program keywords (run method, write method, INCAR settings, etc.) except for mast\_update\_children\_method. The mast\_update\_children\_method will be taken from the ingredient type specified between the parent and that child.

\begin{Verbatim}[commandchars=\\\{\}]
perfect\_stat (stat\_to\_defect)
    defect\_opt
perfect\_stat (stat\_to\_phonon)
    phonon\_opt1
\end{Verbatim}

If two children need to be the parent of one ingredient, also create a new tree:

\begin{Verbatim}[commandchars=\\\{\}]
perfect\_stat
    defect\_1\_opt
    defect\_2\_opt
defect\_1\_opt, defect\_2\_opt
    neb\_1-2\_opt
\end{Verbatim}

Parent-child relationships are name-based, and the name must also include correct formats for defect labels (defect\_XXX), charge labels (q=XX), neb labels (neb\_XXX-XXX), and phonon labels (phonon\_XXX). These names are important for following the tree structure and for setting the metadata file. Parent-child relationships are specified by these particular folder names. However, once all runs have been completed, post-processing utilities should only look at the metadata file within each run folder, and not at the folder name.

For defects, the labels must correspond to labels in the \code{\$defects} section:

\begin{Verbatim}[commandchars=\\\{\}]
defect\_\textless{}label\textgreater{}
\end{Verbatim}

Defect charges are given as q=p0 for no charge, q=nX for negative charge X (remember that negative charge means more electrons), and q=pX for positive charge X.
(Please note that inducedefect ingredients should be labeled with inducedefect rather than with induce\_defect, which will confuse them with defect ingredient labels.)

For nebs, the labels must correspond to labels in the \code{\$neb} section:

\begin{Verbatim}[commandchars=\\\{\}]
neb\_\textless{}label\textgreater{}
\end{Verbatim}

For phonons, the labels must correspond to labels in the \code{\$phonon} section:

\begin{Verbatim}[commandchars=\\\{\}]
phonon\_\textless{}label\textgreater{}
phonon\_\textless{}label\textgreater{}\_parse
\end{Verbatim}

You may create a fully-specified recipe in which you write out the labels, and also the charges, if necessary, for example:

defect\_opt1\_q=n2 (lowmesh)

However, in many cases it is more convenient to use abbreviations within the recipe.
\code{\{begin\}} and \code{\{end\}} tags specify sections that can be looped over for as many defect labels \code{\textless{}N\textgreater{}} are specified in the \code{\$defects} section of the input file and NEB labels \code{\textless{}B-E\textgreater{}}, where \code{\textless{}B\textgreater{}} and \code{\textless{}E\textgreater{}} are also defect labels, as specified in the \code{\$neb} section of the input file.

Charges \code{\textless{}Q\textgreater{}} are given by the charge range in the \code{\$defects} section. Available charges are carried into the \code{\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}} labels based on which charges are available to both the \code{\textless{}B\textgreater{}} and the \code{\textless{}E\textgreater{}} defect in the label.

Note that defect endpoints need to be the parents of all NEB optimizations and NEB static calculations.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
Recipe NEBtest
perfect\_opt1 (lowmesh)
    perfect\_opt2
        perfect\_stat (static)
        \PYGZob{}begin\PYGZcb{}
        inducedefect\_\textless{}N\textgreater{} (inducedefect)
            defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_opt1 (lowmesh\_defect)
                defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_opt2 (defect\_relax)
                    defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_stat (static)
        \PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_stat (static)
    phonon\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{} (phonon)
        phonon\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{}\_parse (phononparse)
\PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
defect\_\textless{}B\textgreater{}\_\textless{}Q\textgreater{}\_stat (static\_to\_neb), defect\_\textless{}E\textgreater{}\_\textless{}Q\textgreater{}\_stat (static\_to\_neb)
    neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_opt1 (neb\_to\_neb)
        neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_opt2 (neb\_to\_nebstat)
            neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_stat (nebstat\_to\_phonon)
    neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_opt2 (neb\_to\_nebstat)
    neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_stat (nebstat\_to\_phonon)
\PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_stat (nebstat\_to\_phonon)
    phonon\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{} (phonon)
        phonon\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{}\_parse (phononparse)
\PYGZob{}end\PYGZcb{}
\end{Verbatim}


\chapter{Examples}
\label{9_0_examples::doc}\label{9_0_examples:examples}

\section{Full example: defects, charges, NEB, phonons}
\label{9_0_examples:full-example-defects-charges-neb-phonons}
Recipe:

\begin{Verbatim}[commandchars=\\\{\}]
Recipe OptimizeWorkflow
perfect\_opt1 (lowmesh)
    perfect\_opt2
        perfect\_stat (static)
        \PYGZob{}begin\PYGZcb{}
        inducedefect\_\textless{}N\textgreater{} (inducedefect)
            defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_opt1 (lowmesh\_defect)
                defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_opt2 (defect\_relax)
                    defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_stat (static)
        \PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_stat (static)
    phonon\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{} (phonon)
        phonon\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{}\_parse (phononparse)
\PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
defect\_\textless{}B\textgreater{}\_\textless{}Q\textgreater{}\_stat (static\_to\_neb), defect\_\textless{}E\textgreater{}\_\textless{}Q\textgreater{}\_stat (static\_to\_neb)
    neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_opt1 (neb\_to\_neb)
        neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_opt2 (neb\_to\_nebstat)
            neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_stat (nebstat\_to\_phonon)
    neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_opt2 (neb\_to\_nebstat)
    neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_stat (nebstat\_to\_phonon)
\PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
neb\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_stat (nebstat\_to\_phonon)
    phonon\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{} (phonon)
        phonon\_\textless{}B-E\textgreater{}\_\textless{}Q\textgreater{}\_\textless{}P\textgreater{}\_parse (phononparse)
\PYGZob{}end\PYGZcb{}
\end{Verbatim}

Input file:

\begin{Verbatim}[commandchars=\\\{\}]
\# Small demo for NEB workflow
\$mast
system\_name PhononNebTest
\$end

\$structure
coord\_type fractional

begin elementmap
X1 Al
X2 Mg
end

begin lattice
3.5 0 0
0 3.5 0
0 0 3.5
end

begin coordinates
X1 0.0000000000 0.0000000000 0.0000000000
X1 0.5000000000 0.5000000000 0.0000000000
X1 0.0000000000 0.5000000000 0.5000000000
X1 0.5000000000 0.0000000000 0.5000000000
end

\$end

\$defects
threshold 1e-4
coord\_type fractional

begin int1
interstitial 0.25 0.25 0.25 X2
phonon host 0.0 0.5 0.5 0.5
charge=-3,-2
end

begin int2
interstitial 0.25 0.25 0.75 X2
phonon host 0.0 0.0 0.0 0.5
phonon int 0.25 0.25 0.75 0.5
charge=-2,-2
end

begin int3
interstitial 0.75 0.25 0.25 X2
phonon host 0.0 0.0 0.0 0.5
phonon int 0.75 0.25 0.25 0.5
charge=-3,-3
end

\$end

\$ingredients
begin ingredients\_global
mast\_nodes         1
mast\_multiplyencut 1.5
mast\_ppn           8
mast\_queue         morgan1
mast\_exec          //opt/mpiexec/bin/mpiexec //share/apps/bin/vasp5.2\_CNEB
mast\_kpoints       2x2x2 M
mast\_xc            PBE
isif 3
ibrion 2
nsw 191
ismear 1
sigma 0.2
lwave False
lcharg False
prec Accurate
mast\_program   vasp
mast\_write\_method            write\_singlerun
mast\_ready\_method            ready\_singlerun
mast\_run\_method              run\_singlerun
mast\_complete\_method         complete\_singlerun
mast\_update\_children\_method  give\_structure
end

begin inducedefect
mast\_write\_method            no\_setup
mast\_ready\_method            ready\_defect
mast\_run\_method              run\_defect
mast\_complete\_method         complete\_structure
end

begin lowmesh
mast\_kpoints 1x1x1 G
end

begin lowmesh\_defect
mast\_kpoints 1x1x1 G
isif 2
end

begin defect\_relax
isif 2
end

begin static
ibrion -1
nsw 0
mast\_multiplyencut 1.25
mast\_update\_children\_method give\_structure
end

begin static\_to\_neb
ibrion -1
nsw 0
mast\_multiplyencut 1.25
mast\_update\_children\_method give\_structure\_and\_energy\_to\_neb
end

begin phonon
ibrion 5
mast\_write\_method write\_phonon\_single
mast\_update\_children\_method give\_phonon\_single\_forces\_and\_displacements
end

begin phononparse
mast\_program phon
lfree .True.
temperature 1173
nd 3
qa 11
qb 11
qc 11
lsuper .False.
mast\_exec \$MAST\_INSTALL\_PATH/bin/phon\_henry
end

begin neb\_to\_neb
ibrion 1
potim 0.01
lclimb True
spring -5
mast\_kpoints 1x1x1 G
mast\_program   vasp\_neb
mast\_write\_method            write\_neb
mast\_update\_children\_method  give\_neb\_structures\_to\_neb
end

begin neb\_to\_nebstat
ibrion 1
potim 0.01
lclimb True
spring -5
mast\_program   vasp\_neb
mast\_write\_method            write\_neb
mast\_update\_children\_method  give\_neb\_structures\_to\_neb
end

begin nebstat\_to\_phonon
mast\_program   vasp
mast\_write\_method            write\_neb\_subfolders
mast\_ready\_method            ready\_neb\_subfolders
mast\_run\_method              run\_neb\_subfolders
mast\_complete\_method         complete\_neb\_subfolders
mast\_update\_children\_method  give\_saddle\_structure
end

\$end

\$neb
begin int1-int2
X2, 0.25 0.25 0.25, 0.25 0.25 0.75
images 1
phonon int 0.25 0.25 0.5 0.5
phonon host 0.0 0.0 0.0 0.5
end
\$end

\$recipe
recipe\_file phonon\_test\_neb.txt
\$end
\end{Verbatim}


\section{Small example: generic program (here, Genetic Algorithm)}
\label{9_0_examples:small-example-generic-program-here-genetic-algorithm}
Recipe file:

\begin{Verbatim}[commandchars=\\\{\}]
Recipe GenericTest
generictest (generictest)
\end{Verbatim}

More lines could be added to the recipe, and more ingredient types (e.g. test1, test2, etc.), with minor modifications to the keywords given for each ingredient type.

Input file:

\begin{Verbatim}[commandchars=\\\{\}]
\$mast
system\_name GATest
\$end

\$structure
\#The structure actually does not make a difference for this
\#example, as it is not passed into any structure file.
coord\_type fractional
begin lattice
3.5 0 0
0 3.5 0
0 0 3.5
end
begin coordinates
Al 0.0000000000 0.0000000000 0.0000000000
end
\$end

\$ingredients
begin ingredients\_global
mast\_nodes         1
mast\_multiplyencut 1.5
mast\_ppn           1
mast\_queue         default
mast\_exec          //share/apps/vasp5.2\_cNEB
end

begin generictest
\# need to add mastlib to python path to get lammps3.py
\# Amy's GAv14 is currently treated as closed-source
type  Defect
atomlist  [('Si',0,28.0855,-5.3062),('C',4,12.011,-7.371)]
filename   GAoutput
nclust   5
maxgen   5
supercell   (3,3,3)
SolidFile   cBulk.xyz
SolidCell   [13.092,13.092,13.092]
convergence\_scheme   Max-Gen
MUTPB  0.1
mutation\_options  ['Lattice\_Alteration\_small', 'Lattice\_Alteration\_Group', 'Rotation\_geo']
CALC\_Method   LAMMPS
pair\_style  tersoff
pot\_file    SiC.tersoff
LammpsMin   1e-25 1e-25 5000 10000
keep\_Lammps\_files True
Lmin\_style   cg
genealogy   True
allenergyfile  True
BestIndsList   True
mast\_write\_method            write\_ingred\_input\_file input.txt all 0 =;write\_submit\_script;copy\_fullpath\_file //home/tam/tammast/test/gatest/SiC.tersoff SiC.tersoff;copy\_fullpath\_file //home/tam/tammast/test/gatest/cBulk.xyz cBulk.xyz
mast\_ready\_method            ready\_singlerun
mast\_run\_method              run\_singlerun
mast\_complete\_method         file\_has\_string GAoutput.txt "End of Execution"
mast\_update\_children\_method  give\_structure
mast\_started\_file            GAoutput.txt
mast\_program                 None
mast\_exec                    python //home/tam/test\_amy\_GA/GAv14.py input.txt
end
\$end

\$recipe
recipe\_file generic\_test.txt
\$end
\end{Verbatim}


\chapter{Running MAST}
\label{5_0_runningmast:running-mast}\label{5_0_runningmast::doc}

\section{General notes}
\label{5_0_runningmast:general-notes}
Depending on your cluster, you might find it polite to \emph{nice} your processes:

\begin{Verbatim}[commandchars=\\\{\}]
nice -n 19 mast -i input.inp
nice -n 19 mast
\end{Verbatim}

Nice-ing allows the headnode to put its regular functions before the mast processes. MAST should start running within several seconds.


\section{Inputting an input file}
\label{5_0_runningmast:inputting-an-input-file}
To parse an input file, use

\begin{Verbatim}[commandchars=\\\{\}]
mast -i input.inp
\end{Verbatim}

or

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mast} \PYG{o}{-}\PYG{n}{i} \PYG{o}{/}\PYG{o}{/}\PYG{n}{full}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n+nb}{input}\PYG{o}{/}\PYG{n+nb}{file}\PYG{o}{/}\PYG{n}{myinput}\PYG{o}{.}\PYG{n}{inp}
\end{Verbatim}

If your input file specifies any POSCAR or CIF files, those files must be in your current working directory at the time you call MAST.

The input file will be parsed and a recipe directory should be created inside the \code{\$MAST\_SCRATCH} directory, with the appropriate ingredient subdirectories.

Look at the \code{personalized\_recipe.txt}, \code{input.inp}, \code{archive\_input\_options.txt}, and \code{archive\_recipe\_plan.txt} files in the recipe directory to see if the setup agrees with what you think it should be.


\section{Running MAST}
\label{5_0_runningmast:id1}
Running MAST is separate from inputting input files. Use this command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mast}
\end{Verbatim}

This command will do two things:
\begin{enumerate}
\item {} 
Submit all ingredient runs listed in the \code{\$MAST\_CONTROL/submitlist} list to the queue.
\begin{itemize}
\item {} 
The submission command (\code{sbatch}, \code{qsub}, etc.) is based on the platform chosen when you ran \code{python \$MAST\_INSTALL\_PATH initialize.py} during installation.

\item {} 
The exact commands can be found in \code{\$MAST\_INSTALL\_PATH/submit/platforms/\textless{}platform name\textgreater{}/queue\_commands.py}.

\item {} 
If you make changes to that \code{queue\_commands.py} file, run \code{python \$MAST\_INSTALL\_PATH initialize.py} again.

\end{itemize}

\end{enumerate}

Individual ingredients' submission scripts are created automatically through a combination of the \code{\$ingredients} section in the input file, and your the template submission script for your platform
\begin{itemize}
\item {} 
The template submission script is found in \code{\$MAST\_INSTALL\_PATH/submit/platforms/\textless{}platform name\textgreater{}/submit\_template.sh}).

\item {} 
If you make changes to the template, run \code{python \$MAST\_INSTALL\_PATH initialize.py} again.

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Spawn a MAST monitor, or \emph{mastmon}, process on the queue.

\end{enumerate}
\begin{itemize}
\item {} 
Your \code{\$MAST\_INSTALL\_PATH/submit/platforms/\textless{}platform name\textgreater{}/mastmon\_submit.sh} script is responsible for submitting this process.

\item {} 
The script should be set up to use the shortest, fastest turnover queue available (e.g. a serial queue with a maximum walltime of 4 hours, or morganshort on bardeen).

\item {} 
If you make changes to the script, run \code{python \$MAST\_INSTALL\_PATH initialize.py} again.

\end{itemize}

The mastmon process will generate additional entries on \code{\$MAST\_CONTROL/submitlist}, but these entries will not be submitted to the queue until MAST is called again.


\subsection{The MAST monitor}
\label{5_0_runningmast:the-mast-monitor}
The MAST monitor, or mastmon, process goes through the \code{\$MAST\_SCRATCH} directory. It looks at the folders there, which are recipe directories. For each recipe directory, the MAST monitor builds a .recipe plan. from a combination of the input.inp file, the personal\_recipe.txt file, and the status.txt file. It then uses the recipe plan to assess the next steps appropriate for the recipe.

For human troubleshooting of a recipe, the archive\_recipe\_plan.txt file gives information about which ingredients are parents/children of which other ingredients, and which method each parent should use to update each of its child ingredients.

The status.txt files gives the status of each ingredient.

Ingredient statuses are:
\begin{itemize}
\item {} 
I = initialized: The ingredient has just been created from inputting the input file, but nothing has been run.

\item {} 
W = waiting: The ingredient is waiting for parents to complete before it can be staged.

\item {} 
S = staged: All parents have updated this child, but the run is not yet ready to run

\item {} 
P = proceed: The ingredient has written its input files, all parents have updated it, and its run method has been called. The run method usually adds the ingredient to the list at \code{\$MAST\_CONTROL/submitlist}, to be submitted to the queue the next time mast is called. There is no MAST status change between an ingredient proceeding to the submitlist and being submitted to the queue off of the submitlist. However, \code{\$MAST\_CONTROL/submitted} can be used to see which ingredients were just submitted to the queue.

\item {} 
C = complete: The ingredient is complete

\item {} 
E = error: The ingredient has errored out, and \code{mast\_auto\_correct} was set to False in the input file (the default is True)

\item {} 
skip = skip: You can set ingredients to skip in the status.txt file by manually editing the file.

\end{itemize}

The MAST monitor checks the status of all ingredients whose status is not yet complete. The MAST monitor updates each ingredient status in the recipe plan.

Each ingredient is checked to see if it is complete (this is a redundant fast-forward check, since sometimes it is useful to copy over previously completed runs into a MAST ingredient directory.)

If complete, the ingredient updates its children and is changed to Complete

For each Initialized ingredient:
\begin{itemize}
\item {} 
If the ingredient has any parents, it is given status Waiting

\item {} 
Otherwise, it is given status Staged

\end{itemize}

For each Proceed-to-run ingredient:
\begin{itemize}
\item {} 
If the ingredient is now complete, it updates its children and is changed to Complete

\end{itemize}

For each Waiting ingredient:
\begin{itemize}
\item {} 
If all parents are now marked complete, the ingredient is changed to Staged

\end{itemize}

For each Staged ingredient:
\begin{itemize}
\item {} 
If the ingredient is not already ready to run, its write method is called for it to write its input files.

\item {} 
The ingredient.s run method is called, which usually adds its folder to \code{\$MAST\_CONTROL/submitlist}, except in the case of special run methods like run\_defect (to induce a defect)

\item {} 
The ingredient.s status is changed to Proceed.

\end{itemize}

When all ingredients in a recipe are complete, the entire recipe folder is moved from \code{\$MAST\_SCRATCH} to \code{\$MAST\_ARCHIVE}


\subsection{The CONTROL folder}
\label{5_0_runningmast:the-control-folder}
The \code{\$MAST\_CONTROL} folder houses several files:
\begin{itemize}
\item {} 
errormast: Contains any queue errors from running the MAST monitor on the queue

\item {} 
mastoutput: Contains all queue output from running the MAST monitor on the queue, including a printout of the ingredient statuses for all recipes in the \$MAST\_SCRATCH directory

\item {} 
submitlist: The list of all ingredient folders to be submitted to the queue

\item {} 
submitted: A list of all ingredients submitted to the queue the last time the MAST monitor ran

\item {} 
mast.log and archive.\textless{}timestamp\textgreater{}.log: contains MAST runtime information

\end{itemize}

Every file except \code{submitlist} can be periodically deleted to save space.

The \code{errormast} file is written when there is an error, and will need to be deleted for MAST to continue running.


\subsection{The SCRATCH folder}
\label{5_0_runningmast:the-scratch-folder}
The \code{\$MAST\_SCRATCH} folder houses all recipe folders. It also houses a \code{mast.write\_files.lock} file while the MAST monitor is running, in order to prevent several versions of MAST from running at once and simultaneously checking and writing ingredients.
\begin{itemize}
\item {} 
Occasionally, MAST may report that it is locked. If there is no \emph{mastmon} process running or queued on the queue, you may delete the \code{mast.write\_files.lock} file manually.

\end{itemize}


\subsubsection{Skipping recipes or ingredients in the SCRATCH folder}
\label{5_0_runningmast:skipping-recipes-or-ingredients-in-the-scratch-folder}
If a certain recipe has some sort of flaw, or if you want to stop tracking it halfway through, you may have MAST skip over this recipe:
\begin{itemize}
\item {} 
Create an empty (or not, the contents don.t matter) file named MAST\_SKIP in the recipe directory.

\item {} 
Go through \$MAST\_CONTROL/submitlist and delete all ingredients associated with that recipe to keep them from being submitted during the next MAST run.

\end{itemize}

If you would like to skip certain ingredients of a single recipe, edit the recipe's status.txt file and replace ingredients to be skipped with the status \emph{skip} (use the whole word).
\begin{itemize}
\item {} 
To un-skip these ingredients, set them back to W for waiting for parents in status.txt.
\begin{itemize}
\item {} 
\textbf{Be careful if deleting any files for skipped ingredients.}

\item {} 
\textbf{Do not delete the metadata.txt file.}

\item {} 
\textbf{If deleting a file that was obtained from a parent, like a POSCAR file, also set the parent ingredient back to P when you un-skip the child ingredient.}

\end{itemize}

\item {} 
No recipe can be considered complete by MAST if it includes skipped ingredients. However, if you consider the recipe complete, you can move the entire recipe directory out of \code{\$MAST\_SCRATCH} and into \code{\$MAST\_ARCHIVE} or another directory.

\end{itemize}


\subsection{The ARCHIVE folder}
\label{5_0_runningmast:the-archive-folder}
When all ingredients in a recipe are complete, the entire recipe directory is moved from \code{\$MAST\_SCRATCH} to \code{\$MAST\_ARCHIVE}.


\section{Running MAST repeatedly}
\label{5_0_runningmast:running-mast-repeatedly}
The command \code{mast} needs to be run repeatedly in order to move the status of the recipe forward. In order to run mast automatically, use a crontab.

Important notes:
\begin{itemize}
\item {} 
Some clusters may not allow the use of cron. Please check the cluster policy before setting up cron.

\item {} 
Be ready for a lot of notification emails. Crontab on a well-behaved system should send you an email each time it runs, giving you what would have been the output on the screen.

\item {} 
Include \code{. \$HOME/.bashrc} or a similar line to get your MAST environment variables and your usual path setup.

\end{itemize}

Crontab commands are as follows:
\begin{itemize}
\item {} 
\code{crontab -e} to edit your crontab

\item {} 
\code{crontab -l} to view your crontab

\item {} 
\code{crontab -r} to remove your crontab

\end{itemize}

This crontab line will run mast every hour at minute 15, and is usually suitable for everyday use:

\begin{Verbatim}[commandchars=\\\{\}]
15 * * * * . \$HOME/.bashrc; nice -n 19 mast
\end{Verbatim}

This crontab line will run mast every 15 minutes and is ONLY suitable for short testing:

\begin{Verbatim}[commandchars=\\\{\}]
*/15 * * * * . \$HOME/.bashrc; nice -n 19 mast
\end{Verbatim}


\chapter{MAST post-processing utilities}
\label{6_0_tools:tools}\label{6_0_tools::doc}\label{6_0_tools:mast-post-processing-utilities}

\section{Defect formation energy}
\label{6_0_tools:defect-formation-energy}
The defect formation energy tool goes through the output of finished recipes in \$MAST\_ARCHIVE and calculates defect formation energies. It is found in \$MAST\_INSTALL\_PATH/tools.

The defect formation energy tool will create a \code{\textless{}recipe directory\textgreater{}\_dfe\_results} directory in the directory from which it is called.

To run without prompts:

\begin{Verbatim}[commandchars=\\\{\}]
python \$MAST\_INSTALL\_PATH/tools/defect\_formation\_energy \textless{}DFT bandgap\textgreater{} \textless{}experimental bandgap\textgreater{}
\end{Verbatim}

where DFT bandgap is a float for an LDA or GGA bandgap, and experimental bandgap is a float for an experimental or more accurate hybrid calculation bandgap.

To run with prompts:

\begin{Verbatim}[commandchars=\\\{\}]
python \$MAST\_INSTALL\_PATH/tools/defect\_formation\_energy prompt
\end{Verbatim}
\begin{itemize}
\item {} 
Select the desired recipe

\item {} 
Follow the prompts for chemical potential conditions, band gap energy levels, and band gaps for adjustment

\end{itemize}

The two-column printout is Fermi energy on the left, and defect formation energy on the right.


\section{Diffusion coefficient}
\label{6_0_tools:diffusion-coefficient}
Usage of diffusion coefficient calculation tool code:
\begin{enumerate}
\item {} 
This code currently supports 5(fcc) and 8(hcp) frequency models.

\item {} 
The code currently will work in the same directory with other MAST generated folders (\code{neb\_vac*}, \code{phonon\_vac*}, etc.)

\item {} 
Type \code{\$MAST\_INSTALL\_PATH/MAST/utility/diff.py -i \textless{}input\textgreater{}} to run.

\item {} 
The input file should contain the following lines, naming the directories of energies and attempt rates which are specified with respect to different frequencies for the model.

\end{enumerate}
\begin{itemize}
\item {} 
The order of different lines does not matter.

\item {} 
There can be as many \code{\textbackslash{}n} between lines or as many spaces between words, and they will not affect the code.

\item {} 
The keyword at the beginning of each line matters:
\begin{itemize}
\item {} 
\textbf{type} means which frequency model to choose. Either \code{5} or \code{fcc} tells the code that the five-frequency model should be applied, while either \code{8} or \code{hcp} tell the code that the eight-frequency model should be applied.

\item {} 
\textbf{E} and \textbf{v} means energy and attempting rate, respectively. (Currently does not support other characters such as w).

\item {} 
For 5-freq, \textbf{E0\textasciitilde{}E4} should be used to specify the relations with certain directories

\item {} 
For 8-freq, \textbf{Ea, Eb, Ec, EX, Eap (p means prime), Ebp, Ecp, and EXp} should be used. Note they are all case sensitive and should be exactly the same as written here.

\end{itemize}

\item {} 
Generally speaking, each keyword (Exx or vxx) is followed by two words. The first indicates the configuration of the starting point of NEB and the second represents the saddle point. This order should not be changed.

\item {} 
The user can also type only one single float behind the keyword, and the code will then not refer to the directory for the related energy or attempting rate, but simply use the data given.

\item {} 
\textbf{HVf} means the formation energy of vacancy and \textbf{HB} means binding energy (4 configurations will be used for \emph{HB}, so 4 words or 1 float are expected after \emph{HB}).

\item {} 
The current code is not likely to work if these keywords are spelled incorrectly.

\item {} 
\textbf{lattice} indicates the directory in which to find a lattice file.

\item {} 
This script is meant to be run in a recipe directory, as it needs access to all ingredient folders. If running this script from an ingredient, use

\begin{Verbatim}[commandchars=\\\{\}]
mast\_write\_method write\_ingred\_input\_file diffcoeff\_input.txt all 0;write\_submit\_script
mast\_exec cd ..; python \$MAST\_INSTALL\_PATH/tools/diff.py -i \textless{}ingredient\_name\textgreater{}/diffcoeff\_input.txt
\end{Verbatim}

\end{itemize}

Below are two examples of input files:

\begin{Verbatim}[commandchars=\\\{\}]
Ex1:
\$freq
type 5

v1 vac1 vac10-vac1
v2  2
v3 vac3 vac4-vac3
v4  5
v0 vac0 vac00-vac0

E1  vac1 vac10-vac1

E2 vac2   vac20-vac2
E3   0.5
E4 vac4 vac4-vac3
E0 vac0 vac00-vac0
HVf  0.5
\#HVf can also be given as 'perfect vac'
HB  perfect  sub  vac-sub  vac
\$end


Ex2:
\$freq

type hcp

HVf 0.44
HB -0.1
Ea 0.5
Eb 0.5
Ec 0.5
EX 0.5
Eap 0.5
Ebp 0.5
Ecp 0.5
EXp 0.5
va 5
vb 5
vc 5
vX 3
vap 5
vbp 5
vcp 3
vXp 4


\$end
\end{Verbatim}


\section{Defect finder}
\label{6_0_tools:defect-finder}
The defect finder takes a POSCAR file and finds vacancies and interstitials.
The defect finder currently exists in a separate repository.
You may test it online at materialshub.org \textgreater{} Resources \textgreater{} Tools \textgreater{} Defect Finder


\chapter{External Packages}
\label{7_0_externalpackages:external-packages}\label{7_0_externalpackages::doc}
MAST is built using the following packages:
\begin{itemize}
\item {} 
pymatgen, \href{http://pymatgen.org}{pymatgen.org}, Shyue Ping Ong, Anubhav Jai

\item {} 
custodian, Shyue Ping Ong

\item {} 
(Future plans) pymatgen-db, Anubhav Jain, Dan Gunter

\end{itemize}

MAST can interface with:
\begin{itemize}
\item {} 
PHON version 1.36, adapted, \href{http://www.homepages.ucl.ac.uk/~ucfbdxa/phon/phon.html}{PHON webpage}, Dario Alfe, Computer Physics Communications 180, 2622-2633 (2009)

\item {} 
Vienna Ab-initio Simulation Package, \href{https://www.vasp.at/}{VASP website}, Jurgen Hafner, Georg Kresse, Doris Vogtenhuber, Martijn Marsman

\end{itemize}


\chapter{Authors}
\label{8_0_personnel::doc}\label{8_0_personnel:authors}

\section{The MAST Team}
\label{8_0_personnel:the-mast-team}
PI: Professor Dane Morgan

The following programmers are arranged by start date. (+) indicates research performed using MAST.
\begin{itemize}
\item {} 
Tam Mayeshiba + (summer 2010 - present)

\item {} 
Tom Angsten + (spring 2011 - summer 2013)

\item {} 
Dr. Glen Jenness + (spring 2013 - summer 2013)

\item {} 
Kumaresh Visakan Murugan (spring 2013, fall 2013 - present)

\item {} 
Hyunwoo Kim (spring 2013)

\item {} 
Parker Sear (spring 2013 - summer 2013, present)

\item {} 
Nada Alameddine (summer 2013)

\item {} 
Jihad Naja (summer 2013)

\item {} 
Dr. Henry Wu + (summer 2013 - present)

\end{itemize}

The following additional team or project members are arranged by start date:
\begin{itemize}
\item {} 
Ben Shrago (summer 2013)

\item {} 
Amy Kaczmarowski (fall 2013 - present)

\item {} 
Wei Xie (fall 2013 - present)

\item {} 
Zhewen Song + (fall 2013 - present)

\end{itemize}


\chapter{Acknowledgments}
\label{10_0_acknowledgments::doc}\label{10_0_acknowledgments:acknowledgments}
\scalebox{0.500000}{\includegraphics{nsf1.jpg}}

The MAterials Simulation Toolkit (MAST) was developed with funding from the National Science Foundation Grant 1148011. T. Mayeshiba gratefully acknowledges support from the National Science Foundation Graduate Research Fellowship Grant No. DGE-0718123.

\scalebox{0.500000}{\includegraphics{pymatgen.png}}

Many underlying MAST functions are built using pymatgen (\href{http://pymatgen.org}{http://pymatgen.org}), and the MAST team would especially like to thank pymatgen developers Shyue Ping Ong and Anubhav Jain for their assistance.


\chapter{License}
\label{11_0_license::doc}\label{11_0_license:license}
The MAterials Simulation Toolkit is released with the MIT license, reproduced below:

Copyright (c) 2014 University of Wisconsin-Madison Computational Materials Group MAterials Simulation Toolkit (MAST) Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ``Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
