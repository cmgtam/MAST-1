#!/usr/bin/env python

import os
import time
import shutil
import optparse # Allows for some command line option parsing
import glob
import subprocess 
import logging

from MAST.mast import MAST
from MAST.utility import MASTFile
from MAST.parsers import InputParser
from submit import queue_commands
from MAST.utility import dirutil
from MAST.utility import MASTError
from MAST.utility import loggerutils
def main():
    parser = optparse.OptionParser()
    parser.add_option('-m', '--mode', dest='mode', default='interface',
                      help='Determines which mode is used (see README for more info)')
    parser.add_option('-i', '--input', dest='input', default=None,
                      help='Input file to use to run MAST with (sets mode to input)')
    parser.add_option('-o', '--output', dest='output', default=None,
                      help='Output file to print MAST information about run to')
    parser.add_option('-r', '--runmode', dest='runmode', default='run',
                      help='Use "check" to check the CONTROL folder and print errors.\n Use "list" to print the list of runs on the submitlist.')
    parser.add_option('-s', '--status', dest='status', default=None,
                        help='Print the status of a the recipe in a specified folder.')
    parser.add_option('-v', '--verbose', dest='verbose', default='0',
                      help="Run with verbose messages.")

    (mastopt, mastarg) = parser.parse_args()

    print "-------------------------"
    print 'Welcome to the MAterials Simulation Toolkit (MAST), September 2013 version.'
    print "-------------------------"

    logger = loggerutils.initialize_short_logger(os.path.join(os.getenv("MAST_CONTROL"),"bin_mast.log"))

    # Set mode to input if an input file is given
    if (mastopt.input is not None):
        mastopt.mode = 'input'

    # Set a default file name
    if (mastopt.mode == 'input') and (mastopt.input is None):
        mastopt.input = 'mast.inp'

    if (mastopt.mode == 'input') and (mastopt.output is None):
        mastopt.output = 'mast.out'

    if (mastopt.mode == 'interface') and (mastopt.runmode is None):
        mastopt.runmode = 'run'

    if (mastopt.mode == 'interface') and (mastopt.runmode == 'run') and (mastopt.status == None):
        display_errors()
        display_displayme_lines()
        move_log()
        dirutil.lock_directory(dirutil.get_mast_scratch_path(), 100) 
        queue_commands.submit_from_submission_list()
        queue_commands.clear_submission_list()
        display_recent_submissions()
        dirutil.unlock_directory(dirutil.get_mast_scratch_path())
        dirutil.lock_directory(dirutil.get_mast_scratch_path(), 1)
        mycwd=os.getcwd()
        subdir = os.path.join(dirutil.get_mast_install_path(),'submit')
        os.chdir(subdir)
        mycommand=queue_commands.queue_submission_command() #run the submit.sh script in $MAST_SCRATCH/submit which creates a mastmon in order to do status checking on a compute node
        mysub = subprocess.Popen(mycommand, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        mysub.wait()
        os.chdir(mycwd)
    if (mastopt.mode == 'input'):
        display_errors()
        move_log()
        mast = MAST(inputfile=mastopt.input, outputfile=mastopt.output)
        mast.check_independent_loops()

    if (mastopt.mode == 'interface') and (mastopt.runmode == 'check'):
        display_errors()

    if (mastopt.mode == 'interface') and (mastopt.runmode == 'list'):
        mycheck = subprocess.Popen(['cat %s/submitlist' % os.getenv("MAST_CONTROL")],shell=True)
        mycheck.wait()
    if (mastopt.mode == 'interface') and not mastopt.status == None:
        mydir = str(mastopt.status)
        mycheck = subprocess.Popen(['cat %s/status.txt' % mastopt.status],shell=True)
        mycheck.wait()

def move_log():
    """Move logfile to archive.timestamp.log
    """
    logfile = "%s/mast.log" % os.getenv("MAST_CONTROL")
    errorpath = "%s/errormast" % os.getenv("MAST_CONTROL")
    if os.path.isfile(logfile):
        shutil.move(logfile, "%s/archive.log.%s" % (os.getenv("MAST_CONTROL"),time.strftime('%Y%m%dT%H%M%S')))
    if os.path.isfile(errorpath):
        errorfile = MASTFile(errorpath)
        if len(errorfile.data) > 0:
            shutil.move(errorpath, "%s/archive.errormast.%s" % (os.getenv("MAST_CONTROL"),time.strftime('%Y%m%dT%H%M%S')))

def display_errors():
    """Display errors."""
    #print "ERROR lines from mast.log:"
    #mycheck = subprocess.Popen(['grep ERROR %s/mast.log' % os.getenv("MAST_CONTROL")],shell=True)
    #mycheck.wait()
    #print "--------------------------"
    #print "Additional errors or explanations printed below:"
    errorpath="%s/errormast" % os.getenv("MAST_CONTROL")
    if not os.path.isfile(errorpath):
        return
    myerrormast = MASTFile(errorpath)
    if len(myerrormast.data) > 0:
        print "--------------------------"
        print "Errors below indicate that MAST errored out the last time it ran. Please correct the error(s) and remove the mast.write_files.lock file in %s." % os.getenv("MAST_SCRATCH")
        for eline in myerrormast.data:
            print eline.strip()
        print "--------------------------"
        move_log()
        raise MASTError("bin/mast","Fix previous MAST error before running MAST again. Remove the mast.write_files.lock file in %s." % os.getenv("MAST_SCRATCH"))
    #mycheck = subprocess.Popen(['cat %s/errormast' % os.getenv("MAST_CONTROL")],stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    #myerrs=mycheck.communicate()[0]
    #mycheck.wait()

def display_recent_submissions():
    """Display recent submissions to the queue."""
    print "--------------------------"
    print "Jobs submitted to the queue: (%s/just_submitted):" % os.getenv("MAST_CONTROL")
    print "--------------------------"
    justsubmitted=MASTFile(os.path.join(os.getenv("MAST_CONTROL"),'just_submitted'))
    for line in justsubmitted.data:
        print line.strip()

def display_displayme_lines():
    """Display all lines marked DISPLAY_ME from the mast.log logfile.
        Each line should be in the format:
        <logging level>:DISPLAY_ME:<recipe folder>:<message>
    """
    logpath = os.path.join(os.getenv("MAST_CONTROL"),'mast.log')
    if not os.path.isfile(logpath):
        return
    print "-------------------------"
    print " Recipe information from previous MAST run:"
    print "-------------------------"
    alllog=MASTFile(os.path.join(os.getenv("MAST_CONTROL"),'mast.log'))
    for line in alllog.data:
        displine=line.strip()
        print displine
    #    rname=displine[2]
    #    rmsg=displine[3]
    #    if not rname in immeddict.keys():
    #        immeddict[rname]=list()
    #    immeddict[rname].append(rmsg)
    #rkeys=immeddict.keys()
    #rkeys.sort()
    #for rkey in rkeys:
    #    print "%s:" % rkey
    #    for msgline in immeddict[rkey]:
    #        print "    %s" % msgline
    #mycheck = subprocess.Popen(['grep DISPLAY_ME %s/mast.log' % os.getenv("MAST_CONTROL")],shell=True)
    #mycheck.wait()


if __name__ == '__main__':
    main()

