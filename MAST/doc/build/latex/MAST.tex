% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{MAST Documentation}
\date{September 19, 2014}
\release{1.2.0}
\author{University of Wisconsin-Madison Computational Materials Group}
\newcommand{\sphinxlogo}{\includegraphics{MAST_logo_200px.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Changes in version 1 2 0}
\label{16_0_whatsnew::doc}\label{16_0_whatsnew:changes-in-version-1-2-0}\label{16_0_whatsnew:materials-simulation-toolkit-mast-manual}
\textbf{Additions:}
\begin{itemize}
\item {} 
Finite size scaling support (the ``\textless{}S\textgreater{}'' tag) has been added. See {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}}, {\hyperref[3_1_3_recipe::doc]{\emph{The Recipe section}}}, and {\hyperref[6_0_postprocessingtools::doc]{\emph{MAST post-processing utilities}}}.

\end{itemize}

\textbf{Fixes:}
\begin{itemize}
\item {} 
The {\hyperref[8_0_2_gbdiff::doc]{\emph{Effective Grain Boundary Diffusivity Calculator}}} and {\hyperref[8_0_3_diffanalyzer::doc]{\emph{Particle Trajectory Diffusion Analysis}}} documentation is updated to reflect that source code for the non-python packages is only on github, and does not get packaged into the pypi package.

\end{itemize}

\textbf{Changes for users:}
\begin{itemize}
\item {} 
The \code{\$recipe} section of the input file now requires the recipe to be entered directly.
\begin{itemize}
\item {} 
Do not use a text file name any more.

\item {} 
Do not start with a recipe name line.

\item {} 
The \code{MAST\_RECIPE\_PATH} environment variable is no longer necessary.

\end{itemize}

\item {} 
When the input file is processed, it will create a \code{\$personal\_recipe} section directly in the input file.
\begin{itemize}
\item {} 
There is no longer a \code{personal\_recipe.txt} file in the recipe directory.

\item {} 
If copying an input file for use in a new recipe, delete the \code{\$personal\_recipe} section from the new copy of the input file.

\end{itemize}

\item {} 
MAST will now tell you where it was installed when you run \code{mast}.

\item {} 
Platform support is now all under \code{\textless{}MAST installation directory\textgreater{}/submit/platforms/}.
\begin{itemize}
\item {} 
The \code{platforms} folder is no longer copied to \code{\$MAST\_CONTROL}. See {\hyperref[1_0_installation::doc]{\emph{Installation}}} for creating and modifying platforms.

\end{itemize}

\end{itemize}

\textbf{Changes for programmers:}
\begin{itemize}
\item {} 
Automatic citation support files are no longer copied to \code{\$MAST\_CONTROL}. They are located in \code{\textless{}MAST installation directory\textgreater{}/summary/citations}.

\item {} 
Program key files are no longer copied to \code{\$MAST\_CONTROL}. They are located in \code{\textless{}MAST installation directory\textgreater{}/ingredients/programkeys}.

\item {} 
Optimizer.py is no longer copied to \code{\$MAST\_CONTROL}. It is located in \code{\textless{}MAST installation directory\textgreater{}/structopt}

\end{itemize}


\chapter{Introduction}
\label{0_0_introduction:introduction}\label{0_0_introduction::doc}
Welcome to the MAterials Simulation Toolkit (MAST)!

MAST is an automated workflow manager and post-processing tool.

MAST focuses on diffusion and defect workflows that use density functional theory. It interfaces primarily with the Vienna Ab-initio Simulation Package (VASP).

However, MAST can be generalized to other workflows and codes.


\section{The MAST Kitchen}
\label{0_0_introduction:the-mast-kitchen}
MAST uses kitchen terminology to organize the materials simulation workflow.
\begin{itemize}
\item {} 
An {\hyperref[2_0_ingredients::doc]{\emph{Ingredient}}} is a single calculation, like a single VASP calculation resulting in a relaxed structure and energy.

\item {} 
A {\hyperref[4_0_recipe::doc]{\emph{Recipe}}} is a collection of several ingredients, including information about how the ingredients are combined together.
\begin{itemize}
\item {} 
As in a cooking recipe, ingredients may need to be addressed in a logical order, with some ingredients depending on other ingredients.

\item {} 
{\hyperref[3_1_3_recipe::doc]{\emph{The Recipe section}}} defines this order, or workflow.

\end{itemize}

\end{itemize}

When MAST reads an input file, it creates a recipe in the \code{\$MAST\_SCRATCH} directory.
\begin{itemize}
\item {} 
Many recipes can reside in \code{\$MAST\_SCRATCH}.

\item {} 
MAST will check and update the recipes in alphanumeric order.

\end{itemize}

When MAST finds that a recipe is complete, it will move the recipe from \code{\$MAST\_SCRATCH} to \code{\$MAST\_ARCHIVE}.


\section{Computing in the MAST Kitchen}
\label{0_0_introduction:computing-in-the-mast-kitchen}\begin{enumerate}
\item {} 
Install MAST (see {\hyperref[1_0_installation::doc]{\emph{Installation}}}).

\item {} 
Plan your workflow.
\begin{itemize}
\item {} 
What are the single calculations you will need (Ingredients)?

\item {} 
Which calculations depend on each other and should be grouped into a Recipe?

\item {} 
What are all of the conditions for each calculation?
\begin{itemize}
\item {} 
Which calculations have a volume change?

\item {} 
Which calculations should be run at fixed volume?

\item {} 
How fine a kpoint mesh does each calculation need?

\item {} 
Etc...

\end{itemize}

\end{itemize}

\item {} 
Run an example file (see {\hyperref[17_0_testmast::doc]{\emph{Trying out MAST}}}) to get a feel for how MAST works.

\item {} 
Copy and modify an example file for your own workflow.

\end{enumerate}

\textbf{Please check your output carefully, especially when setting up a new workflow.}


\chapter{Ingredients}
\label{2_0_ingredients::doc}\label{2_0_ingredients:ingredients}
Each ingredient is a separate calculation. Ingredients make up recipes.

Each ingredient is responsible for updating its child ingredients through an update\_children method.

The ingredient directory will contain:
\begin{itemize}
\item {} 
Any input files written by MAST or delivered by the parent ingredients.

\item {} 
Any output files generated by the calculation

\item {} 
A \code{metadata.txt} file, which stores important information for MAST

\item {} 
A \code{jobids} file, which stores job ID numbers that the ingredient has had on the queue.

\end{itemize}

An ingredient object (created by MAST from the input file, and accessible to MAST while MAST is running) will have:
\begin{itemize}
\item {} 
A name, which is the full path to the ingredient's directory and is automatically generated from information in the input file.

\item {} 
A dictionary of keywords, which come from the ingredient's \textbf{ingredient type} in {\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}}.
\begin{itemize}
\item {} 
Program-specific keywords

\item {} 
MAST keywords, including:
\begin{itemize}
\item {} 
The \textbf{write} method: which files the ingredient should write out before running (e.g., create the INCAR)

\item {} 
The \textbf{ready} method: how MAST can tell if the ingredient is ready to run (often, in addition to writing its own files, an ingredient must also wait for data from its parent ingredient(s)).

\item {} 
The \textbf{run} method: what MAST should do to run the ingredient (e.g. submit a submission script to a queue, or perform some other action)

\item {} 
The \textbf{complete} method: how MAST can tell if the ingredient is considered complete

\item {} 
The \textbf{update children} method: what information an ingredient passes on to its children, and how this information is passed on

\end{itemize}

\end{itemize}

\item {} 
A pymatgen Structure object representing the very first structure created from {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}}.

\end{itemize}


\chapter{Recipes}
\label{4_0_recipe:recipes}\label{4_0_recipe::doc}
Each recipe is a collection of ingredients.

The recipe directory will contain:
\begin{itemize}
\item {} 
An \code{input.inp} file, which is a copy of the original input file and is used by MAST when checking the recipe. The original input file is not used. This copy also contains {\hyperref[3_1_4_personalrecipe::doc]{\emph{The Personal Recipe section}}}, which is not in the original input file.

\item {} 
Archive files from the initial setup of the recipe directory

\item {} 
Ingredient directories

\item {} 
A top-level \code{metadata.txt} file, which stores important information for MAST

\item {} 
A \code{status.txt} file listing the status of each ingredient

\item {} 
A \code{mast\_recipe.log} file logging actions taken by MAST on the recipe and its ingredients

\end{itemize}

A recipe object (created by MAST from the input file, and accessible to MAST while MAST is running) will have:
\begin{itemize}
\item {} 
A name, which is the full path to the recipe's directory

\item {} 
Several dictionaries which specify:
\begin{itemize}
\item {} 
Which ingredient directories exist

\item {} 
Which ingredients have parents, and the names of those parent ingredients

\item {} 
Which method(s) each ingredient should run for each mast\_xxx\_method (see {\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}})
\begin{itemize}
\item {} 
Which method(s) each ingredient should run for its mast\_update\_children\_method, depending on the name of the child ingredient

\end{itemize}

\end{itemize}

\end{itemize}


\chapter{Installation}
\label{1_0_installation:installation}\label{1_0_installation::doc}

\section{Do pre-installation steps}
\label{1_0_installation:do-pre-installation-steps}

\subsection{Locate your user profile}
\label{1_0_installation:locate-your-user-profile}
Your user profile will set up environment variables like \code{\$PATH} when you log in.

This installation will ask you to modify your user profile several times.

If you are comfortable modifying your user profile, please skip to {\hyperref[1_0_installation:use-cluster-correctly]{\emph{Use your cluster correctly}}}.

For others:
\begin{itemize}
\item {} 
Your user profile is probably located in your home directory as \code{//home/\textless{}username\textgreater{}/\textless{}user profile name\textgreater{}}, for example, \code{//home/\textless{}username\textgreater{}/.bashrc}

\item {} 
Common user profile names are \code{.bashrc}, \code{.bash\_profile}, \code{.profile}, and \code{.profile\_user}
\begin{itemize}
\item {} 
These names usually start with a dot.

\item {} 
You may need to use the command \code{ls -a} to see these ``hidden'' files.

\item {} 
Sometimes you may need to create your own user profile file.
\begin{itemize}
\item {} 
For example, you may have a \code{.profile} file listed, but when you look at it, it tells you to create and modify a \code{.profile\_user} file.

\end{itemize}

\end{itemize}

\item {} 
\textbf{After you save your changes to the user profile, you need to log out and then log back in, in order to see the changes take effect.}
\begin{itemize}
\item {} 
Alternately, you can \code{source \textless{}user profile name\textgreater{}}, but occasionally this command will produce complications, for example, in path order.

\end{itemize}

\end{itemize}

If you cannot locate your user profile, please contact your system administrator.


\subsection{Use your cluster correctly}
\label{1_0_installation:use-your-cluster-correctly}\label{1_0_installation:use-cluster-correctly}
For this installation, please follow the correct procedures in order to avoid excessive headnode use on your cluster.
\begin{itemize}
\item {} 
For example, you may want to preface every command with \code{nice -n 19} in order to reduce headnode load.

\item {} 
Or, your cluster may have a dedicated compile node, or it may support interactive queue submission.

\end{itemize}

Please check with your cluster administrator if you are unsure of the correct procedures to user.


\section{Verify your Python version}
\label{1_0_installation:verify-your-python-version}
Check your version of python: \code{python -{-}version}
\begin{itemize}
\item {} 
If your version of python is a 2.7 version (e.g. 2.7.3), skip to {\hyperref[1_0_installation:verify-numpy-scipy]{\emph{Verify that python has numpy and scipy}}}.

\item {} 
Otherwise, go to {\hyperref[1_0_installation:locate-other-python]{\emph{Locate and use an available but non-default 2.7 version of python}}}.

\end{itemize}


\subsection{Locate and use an available but non-default 2.7 version of python}
\label{1_0_installation:locate-and-use-an-available-but-non-default-2-7-version-of-python}\label{1_0_installation:locate-other-python}
For clusters using the ``module'' system, like Stampede or DLX, check which modules are available using \code{module avail python} or \code{module avail}

For clusters not using the module system, you may need to look in \code{//share/apps} or in a similar shared directory, or ask your system administrator.
\begin{itemize}
\item {} 
If you cannot find an existing version of python 2.7, skip to {\hyperref[1_0_installation:install-local-python]{\emph{Install a local version of python with numpy and scipy}}}.

\item {} 
If you did find an existing version of python 2.7, make sure that it is defaulted to be used first.
\begin{enumerate}
\item {} 
Add the appropriate line to your user profile.
\begin{itemize}
\item {} 
If the version found was a module, then:
\begin{itemize}
\item {} 
Add a line like the following:

\begin{Verbatim}[commandchars=\\\{\}]
module load python
\end{Verbatim}

\item {} 
The actual wording may depend on the module name. Here, we are assuming that ``python'' is the module name.

\end{itemize}

\item {} 
If the version found was located in an explicit directory and not found through the module system:
\begin{itemize}
\item {} 
Add a line like the following:

\begin{Verbatim}[commandchars=\\\{\}]
export PATH=\PYGZlt{}path\PYGZus{}to\PYGZus{}python2.7\PYGZgt{}:\PYGZdl{}PATH
\end{Verbatim}

\item {} 
For example:

\begin{Verbatim}[commandchars=\\\{\}]
export PATH=//share/apps/EPD\PYGZus{}64bit/epd\PYGZus{}free\PYGZhy{}7.3\PYGZhy{}2\PYGZhy{}rh5\PYGZhy{}x86\PYGZus{}64/bin:\PYGZdl{}PATH
\end{Verbatim}

\end{itemize}

\end{itemize}

\item {} 
Then, log out and log back in.

\item {} 
Type \code{which python} or \code{python -{-}version} to make sure your default version is now the correct version.

\end{enumerate}

\end{itemize}

If you already use python for something else and shifting python versions will interfere with other programs, for example, you routinely use Python 2.4.3 instead and your other programs break if called from python 2.7.3, please contact your system administrator or the MAST development team.

Otherwise, go on to {\hyperref[1_0_installation:verify-numpy-scipy]{\emph{Verify that python has numpy and scipy}}}.


\subsection{Verify that python has numpy and scipy}
\label{1_0_installation:verify-that-python-has-numpy-and-scipy}\label{1_0_installation:verify-numpy-scipy}
Check to see if your python version has numpy and scipy:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}

And then, from the python prompt:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}
\end{Verbatim}

If you receive an ImportError, then you must install a local version of python which has numpy and scipy. Go to {\hyperref[1_0_installation:install-local-python]{\emph{Install a local version of python with numpy and scipy}}}.


\subsection{Install a local version of python with numpy and scipy}
\label{1_0_installation:install-a-local-version-of-python-with-numpy-and-scipy}\label{1_0_installation:install-local-python}
The EPD/Canopy version is preferred because it includes numpy and scipy already. Download this version from \href{https://www.enthought.com/downloads/}{EPD Free Canopy}
\begin{itemize}
\item {} 
Run the setup script. (e.g. \code{bash ./canopy-1.0.3-rh5-64.sh})

\item {} 
Follow the prompts and specify a local installation (use spacebar to scroll through the license file).

\end{itemize}

Add a line to your user profile to make this python installation your default python, for example:

\begin{Verbatim}[commandchars=\\\{\}]
export PATH=//home/\PYGZlt{}username\PYGZgt{}/Canopy/appdata/canopy\PYGZhy{}1.0.3.1262.rh5\PYGZhy{}x86\PYGZus{}64/bin:\PYGZdl{}PATH
\end{Verbatim}
\begin{itemize}
\item {} 
Do not just use the \code{Canopy/bin} directory, as python modules will not load properly

\item {} 
Log out and log back in.

\end{itemize}

Check your version of python: \code{python -{-}version}

The version given must be the correct version.

Check that numpy and scipy are installed, which they should be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{python}
\end{Verbatim}

And then at the python prompt:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}
\end{Verbatim}


\section{Install dependencies}
\label{1_0_installation:install-dependencies}
MAST requires pymatgen and custodian, each of which has several dependencies, which also have their own dependencies.


\subsection{pip note for the python-savvy}
\label{1_0_installation:pip-note-for-the-python-savvy}
If you have \code{pip}, it is possible but sometimes unusually complicated to use pip to install MAST and its dependencies.
\begin{itemize}
\item {} 
If the \code{pip} command does not exist (\code{which pip} does not return anything), go on to {\hyperref[1_0_installation:manual-installation]{\emph{Install dependencies manually}}}.

\end{itemize}

If you have the \code{pip} command, it may be worth trying the following:

\begin{Verbatim}[commandchars=\\\{\}]
pip install pymatgen==2.7.9 \PYGZhy{}\PYGZhy{}user
pip install custodian==0.7.5 \PYGZhy{}\PYGZhy{}user
pip install MAST \PYGZhy{}\PYGZhy{}user
\end{Verbatim}
\begin{itemize}
\item {} 
If this series of commands actually worked without errors, then do a quick installation of ASE following the instructions on the \href{https://wiki.fysik.dtu.dk/ase/download.html}{ASE website} and then skip to {\hyperref[1_0_installation:add-local-bin]{\emph{Add the .local/bin directory, if necessary}}}.

\item {} 
If you have never used pip before, and using pip created a \code{\$HOME/.local} folder for you for the first time, and you encounter errors, delete the \code{\$HOME/.local} folder and go on to {\hyperref[1_0_installation:manual-installation]{\emph{Install dependencies manually}}}.

\item {} 
If you encountered errors and your \code{\$HOME/.local} folder already existed, carefully remove the most recent package folders under \code{\$HOME/.local/lib/python2.7/site-packages} and go on to {\hyperref[1_0_installation:manual-installation]{\emph{Install dependencies manually}}}.

\end{itemize}


\subsection{Install dependencies manually}
\label{1_0_installation:manual-installation}\label{1_0_installation:install-dependencies-manually}
Download \code{tar.gz} files for the following dependencies from the \href{https://pypi.python.org}{Python Package Index}
\begin{itemize}
\item {} 
The versions listed are known to be compatible with MAST and with each other.

\item {} 
Using other version numbers may require adjustments to the entire list.
\begin{itemize}
\item {} 
In this case, look at \code{install\_requires} inside the \code{setup.py} file to see which version numbers may be required.

\end{itemize}

\end{itemize}

Dependency list:

\begin{Verbatim}[commandchars=\\\{\}]
PyCifRW\PYGZhy{}3.6.2.tar.gz
pybtex\PYGZhy{}0.18.tar.gz
pyhull\PYGZhy{}1.4.5.tar.gz
monty\PYGZhy{}0.3.4.tar.gz
PyYAML\PYGZhy{}3.11.tar.gz
requests\PYGZhy{}2.3.0.tar.gz
pymatgen\PYGZhy{}2.7.9.tar.gz
custodian\PYGZhy{}0.7.5.tar.gz
\end{Verbatim}

Also get:

\begin{Verbatim}[commandchars=\\\{\}]
python\PYGZhy{}ase\PYGZhy{}3.8.1.3440.tar.gz
\end{Verbatim}

from the \href{https://wiki.fysik.dtu.dk/ase/download.html}{ASE website}

Upload each of these .tar.gz files onto your cluster.
Uncompress and untar each of these files (\code{tar -xzvf \textless{}tar.gz filename\textgreater{}}, for example, \code{tar -xzvf PyCifRW-3.6.2.tar.gz}).

Following the order listed above, go to the untarred directory for each package and run the setup script as follows:

\begin{Verbatim}[commandchars=\\\{\}]
tar \PYGZhy{}xzvf PyCifRW\PYGZhy{}3.6.2.tar.gz
cd PyCifRW\PYGZhy{}3.6.2
python setup.py install (\PYGZhy{}\PYGZhy{}user, depending on the notes below)
\end{Verbatim}

And so on for all the packages.

If you are using a system-wide python, like from the module system or in a shared directory, then you need the \code{-{-}user} tag, and will use the command:

\begin{Verbatim}[commandchars=\\\{\}]
python setup.py install \PYGZhy{}\PYGZhy{}user
\end{Verbatim}

In this case, the modules will end up in a folder like \code{//home/\textless{}username\textgreater{}/.local/lib/python2.7/site-packages}.

If you are using your own locally-installed python, you can just use:

\begin{Verbatim}[commandchars=\\\{\}]
python setup.py install
\end{Verbatim}

In this case, the modules will end up in your python installation directory, for example, \code{//home/\textless{}username\textgreater{}/Canopy/appdata/canopy-1.0.3.1262.rh5-x86\_64/lib/python2.7/site-packages}.

If pymatgen cannot be installed because gcc cannot be found in order to compile spglib, then please see your system administrator.


\subsection{Add the .local/bin directory, if necessary}
\label{1_0_installation:add-local-bin}\label{1_0_installation:add-the-local-bin-directory-if-necessary}
If you have a \code{\$HOME/.local/bin} directory from a \code{-{-}user} installation from any of the previous steps, add this directory to your \code{\$PATH} environment variable by adding a line to your user profile, for example:

\begin{Verbatim}[commandchars=\\\{\}]
export PATH=\PYGZdl{}HOME/.local/bin:\PYGZdl{}PATH
\end{Verbatim}

(This line can go either before or after any other \code{export PATH} lines you might have in your user profile.)

Then log out and log back in.

If you were using your own locally-installed python, then you would have already added the correct bin directory to your user profile in the {\hyperref[1_0_installation:install-local-python]{\emph{Install a local version of python with numpy and scipy}}} step.


\section{Set up the pymatgen VASP\_PSP\_DIR}
\label{1_0_installation:vasp-psp-dir}\label{1_0_installation:set-up-the-pymatgen-vasp-psp-dir}
This step is necessary if you are running VASP with MAST. If you are not running VASP with MAST, skip to {\hyperref[1_0_installation:install-mast]{\emph{Install MAST}}}.


\subsection{Set up the pseudopotential folders}
\label{1_0_installation:set-up-the-pseudopotential-folders}
Locate the VASP pseudopotentials. If you cannot locate the VASP pseudopotentials, contact your system administrator or another person who uses VASP on the cluster.

\code{which potcar\_setup.py} should return the pymatgen utility for setting up your pseudopotential directories in the way that pymatgen requires.
If this command does not return a file location, then probably \code{\$HOME/.local/bin} or \code{\textless{}python installation directory\textgreater{}/bin} is missing from your \code{\$PATH} environment variable. See {\hyperref[1_0_installation:add-local-bin]{\emph{Add the .local/bin directory, if necessary}}}.

Run \code{potcar\_setup.py}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{potcar\PYGZus{}setup}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}
\begin{itemize}
\item {} 
The first directory address that you give to the utility is the directory that contains a few subdirectories, for example: potpaw\_GGA, potpaw\_LDA.52, potpaw\_PBE.52, potUSPP\_LDA, potpaw\_LDA, potpaw\_PBE, potUSPP\_GGA.
\begin{itemize}
\item {} 
These subdirectories themselves contain many sub-subdirectories with element names like Ac, Ac\_s, Zr\_sv, etc.

\end{itemize}

\item {} 
The second directory address that you give should be a new directory that you create.

\end{itemize}

Once the new pymatgen-structured folders have been created, rename the GGA PBE folder to \code{POT\_GGA\_PAW\_PBE}.

Later on, ingredients with a value of \code{pbe} for the ingredient keyword \code{mast\_xc} will draw pseudopotentials out of this folder (see {\hyperref[3_0_inputfile::doc]{\emph{Input File}}}).

Rename the GGA PW91 folder to \code{POT\_GGA\_PAW\_PW91}. Ingredients with a value of \code{pw91} for the ingredient keyword \code{mast\_xc} will draw pseudopotentials out of this folder.

Example of running the python setup tool:

\begin{Verbatim}[commandchars=\\\{\}]
Please enter full path where the POT\PYGZus{}GGA\PYGZus{}PAW\PYGZus{}PBE, etc.
subdirs are present.
If you obtained the PSPs directly from VASP, this should
typically be the directory that you untar the files to :

//share/apps/vasp\PYGZus{}pseudopotentials/paw

Please enter the fullpath of the where you want to create
your pymatgen resources directory:

//home/\PYGZlt{}username\PYGZgt{}/.local/vasp\PYGZus{}pps
\end{Verbatim}

Rename the folders under \code{//home/\textless{}username\textgreater{}/.local/vasp\_pps}:

\begin{Verbatim}[commandchars=\\\{\}]
mv //home/\PYGZlt{}username\PYGZgt{}/.local/vasp\PYGZus{}pps/\PYGZlt{}pbe\PYGZus{}name\PYGZgt{} //home/\PYGZlt{}username\PYGZgt{}/.local/vasp\PYGZus{}pps/POT\PYGZus{}GGA\PYGZus{}PAW\PYGZus{}PBE

mv //home/\PYGZlt{}username\PYGZgt{}/.local/vasp\PYGZus{}pps/\PYGZlt{}pw91\PYGZus{}name\PYGZgt{} //home/\PYGZlt{}username\PYGZgt{}/.local/vasp\PYGZus{}pps/POT\PYGZus{}GGA\PYGZus{}PAW\PYGZus{}PW91
\end{Verbatim}

For assistance with potcar\_setup.py, please contact the
\href{https://groups.google.com/forum/\#!forum/pymatgen}{Pymatgen support group}


\subsection{Add the VASP\_PSP\_DIR to your user profile}
\label{1_0_installation:add-the-vasp-psp-dir-to-your-user-profile}
Add a line to your user profile exporting the environment variable \code{\$VASP\_PSP\_DIR} to the new pseudopotential directory created above.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
export VASP\PYGZus{}PSP\PYGZus{}DIR=//home/\PYGZlt{}username\PYGZgt{}/.local/vasp\PYGZus{}pps
\end{Verbatim}

Log out and log back in.

Test the change:

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZdl{}VASP\PYGZus{}PSP\PYGZus{}DIR
\end{Verbatim}
\begin{itemize}
\item {} 
Make sure you are getting to the right directory, which has the \code{POT\_GGA\_PAW\_PBE} etc. folders inside it.

\end{itemize}


\section{Install MAST}
\label{1_0_installation:id2}\label{1_0_installation:install-mast}
(If you successfully used \code{pip} to install MAST, go to {\hyperref[1_0_installation:mast-setup]{\emph{Set the MAST environment variables}}}.)
\begin{itemize}
\item {} 
Get the \href{https://pypi.python.org/pypi/MAST}{latest MAST package from the Python Package Index}

\item {} 
Extract the package using \code{tar -xzvf MAST-\textless{}version number\textgreater{}.tar.gz}

\item {} 
Change into the package directory and run \code{python setup.py install} or \code{python setup.py install -{-}user} as you did with the other packages in {\hyperref[1_0_installation:manual-installation]{\emph{Install dependencies manually}}}.

\end{itemize}

You should be prompted to set the MAST environment variables, which is covered in {\hyperref[1_0_installation:mast-setup]{\emph{Set the MAST environment variables}}}.


\subsection{Set the MAST environment variables}
\label{1_0_installation:mast-setup}\label{1_0_installation:set-the-mast-environment-variables}
The MAST setup.py script should have set up a \code{MAST} directory in your home directory, that is, \code{//home/\textless{}username\textgreater{}/MAST}.
\begin{itemize}
\item {} 
This directory is primarily for storing calculations, and should not be confused with the python module directory, which is where the actual MAST python code resides.

\end{itemize}

Inside \code{\$HOME/MAST} there should be:
\begin{enumerate}
\item {} 
A \code{SCRATCH} folder:
\begin{itemize}
\item {} 
Each time an input file is given to MAST, MAST will create a recipe directory inside this folder.

\item {} 
Each recipe directory will itself contain ingredient, or calculation, directories. Calculations will be submitted to the queue from inside these ingredient directories.

\item {} 
Multiple recipes may reside in \code{SCRATCH} at the same time, and MAST will evaluate them alphabetically.

\end{itemize}

\item {} 
An \code{ARCHIVE} folder:
\begin{itemize}
\item {} 
When a recipe directory is complete, MAST will move it from \code{SCRATCH} to \code{ARCHIVE}.

\end{itemize}

\item {} 
A \code{CONTROL} folder:
\begin{itemize}
\item {} 
MAST requires some control files in order to run. It also does some higher-level logging, and stores that output here.

\end{itemize}

\end{enumerate}
\begin{itemize}
\item {} 
On some clusters, like Stampede, the home directory is not where you actually want to store calculations. Instead, there may be a separate ``work'' or ``scratch'' directory. In this case, move the entire \code{\$HOME/MAST} directory into the work or scratch directory, for example:

\begin{Verbatim}[commandchars=\\\{\}]
mv \PYGZdl{}HOME/MAST \PYGZdl{}WORK/.
\end{Verbatim}

\end{itemize}

In this case, the environment variables below should therefore say \code{\$WORK} instead of \code{\$HOME}.
\begin{itemize}
\item {} 
You can also move the MAST directory anywhere else, as long as you set the environment variables correcty.

\end{itemize}

Copy and paste the environment variables into your user profile, setting the paths correctly if you have moved the \code{\$HOME/MAST} directory:

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\PYGZus{}SCRATCH=\PYGZdl{}HOME/MAST/SCRATCH
export MAST\PYGZus{}ARCHIVE=\PYGZdl{}HOME/MAST/ARCHIVE
export MAST\PYGZus{}CONTROL=\PYGZdl{}HOME/MAST/CONTROL
export MAST\PYGZus{}PLATFORM=\PYGZlt{}platform\PYGZus{}name\PYGZgt{}
\end{Verbatim}

For platform\_name, choose from one of the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{aci}
\PYG{n}{bardeen}
\PYG{n}{dlx}
\PYG{n}{korczak}
\PYG{n}{no\PYGZus{}queue\PYGZus{}system}
\PYG{n}{pbs\PYGZus{}generic}
\PYG{n}{sge\PYGZus{}generic}
\PYG{n}{slurm\PYGZus{}generic}
\PYG{n}{stampede}
\PYG{n}{turnbull}
\end{Verbatim}

For example:

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\PYGZus{}PLATFORM=stampede
\end{Verbatim}
\begin{itemize}
\item {} 
If your platform is available by name (not \_generic), then:
\begin{itemize}
\item {} 
Add the four environment variable lines to your user profile as above.

\item {} 
Log out and log back in.

\item {} 
Go to {\hyperref[1_0_installation:additional-setup]{\emph{Additional setup}}}.

\end{itemize}

\item {} 
If your platform is not matched exactly, or you would choose one of the generic choices:
\begin{itemize}
\item {} 
Set the three other environment variables (MAST\_SCRATCH, MAST\_ARCHIVE, and MAST\_CONTROL) in your user profile.

\item {} 
Log out and log back in.

\item {} 
Go to {\hyperref[1_0_installation:make-custom-platform]{\emph{Make a custom platform, if necessary}}}.

\end{itemize}

\end{itemize}


\subsection{Make a custom platform, if necessary}
\label{1_0_installation:make-a-custom-platform-if-necessary}\label{1_0_installation:make-custom-platform}
Run the following command. It should produce some errors, but ignore those and just see where MAST is installed:

\begin{Verbatim}[commandchars=\\\{\}]
mast \PYGZhy{}i none
\end{Verbatim}

For example, output may be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
Welcome to the MAterials Simulation Toolkit (MAST)
Version: 1.1.5
Installed in: .local/lib/python2.7/site\PYGZhy{}packages/MAST
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\end{Verbatim}

and then some errors.

Go to the ``installed in'' directory, and then:

\begin{Verbatim}[commandchars=\\\{\}]
cd submit/platforms
\end{Verbatim}

Identify the closest-matching directory to your actual platform (for example, if you have an SGE platform, this directory would be sge\_generic)

Copy this directory into a new directory inside the \code{platforms} folder, for example:

\begin{Verbatim}[commandchars=\\\{\}]
cp \PYGZhy{}r sge\PYGZus{}generic my\PYGZus{}custom\PYGZus{}sge
\end{Verbatim}

Then, inside your new folder, like \code{my\_custom\_sge}, modify each of the following files as necessary for your platform:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{submit\PYGZus{}template}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{mastmon\PYGZus{}submit}\PYG{o}{.}\PYG{n}{sh}
\PYG{n}{queue\PYGZus{}commands}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

Explanations for each file are given in the following sections. Modify and test each file in your new custom platform folder.

Then, in your user profile, use your new custom folder for the platform name of \code{\$MAST\_PLATFORM}:

\begin{Verbatim}[commandchars=\\\{\}]
export MAST\PYGZus{}PLATFORM=my\PYGZus{}custom\PYGZus{}sge
\end{Verbatim}

Log out and log back in.


\subsubsection{submit\_template.sh}
\label{1_0_installation:submit-template-sh}
\code{submit\_template.sh} is the generic submission template from which ingredient submission templates will be created.
\begin{itemize}
\item {} 
MAST will replace anything inside question marks, for example \code{?mast\_ppn?} with the value of the appropriate keyword.

\end{itemize}

The following keywords may be used; see {\hyperref[3_0_inputfile::doc]{\emph{Input File}}} for more information on each keyword.
\begin{itemize}
\item {} 
mast\_processors

\item {} 
mast\_ppn

\item {} 
mast\_nodes

\item {} 
mast\_queue

\item {} 
mast\_exec

\item {} 
mast\_walltime

\item {} 
mast\_memory

\item {} 
mast\_name (the ingredient name)

\end{itemize}

Examine the template carefully, as an error here will prevent your ingredients from running successfully on the queue.
\begin{itemize}
\item {} 
The provided template should be a good match for its platform.
\begin{itemize}
\item {} 
Otherwise, you can take one of your normal submission templates and substitute in \code{?mast\_xxx?} fields where appropriate.

\end{itemize}

\item {} 
Or, vice versa, you can take the provided template, replace the \code{?mast\_xxx?} fields with some reasonable values, and see if filled-in submission template will run a job if submitted normally using \code{qsub}, \code{sbatch}, etc.

\end{itemize}


\subsubsection{mastmon\_submit.sh}
\label{1_0_installation:mastmon-submit-sh}
\code{mastmon\_submit.sh} is the submission template that will submit the MAST Monitor to the queue every time \code{mast} is called.

The MAST Monitor will check the completion status of every recipe and ingredient in the \code{\$MAST\_SCRATCH} folder.
\begin{itemize}
\item {} 
If you have a recipe you would like to skip temporarily, manually put a file named \code{MAST\_SKIP} inside that recipe's folder in \code{\$MAST\_SCRATCH}. \code{MAST\_SKIP} can be an empty file, or it can contain notes; MAST does not check its contents.

\item {} 
\code{mastmon\_submit.sh} should be set to run on the shortest-wallclock, fastest-turnaround queue available, e.g. a serial queue

\end{itemize}

The \code{mastmon\_submit.sh} script is copied into the \code{\$MAST\_CONTROL} directory the first time you run \code{mast}.

If you see that after you type \code{mast}, no ``mastmon'' process appears on the queue, then test the submission script directly:

\begin{Verbatim}[commandchars=\\\{\}]
cd \PYGZdl{}MAST\PYGZus{}CONTROL
qsub mastmon\PYGZus{}submit.sh (or use sbatch for slurm, etc.)
\end{Verbatim}
\begin{itemize}
\item {} 
Modify the \code{\$MAST\_CONTROL/mastmon\_submit.sh} file (and not the one in the MAST installation directory /submit/platforms/\textless{}platform\textgreater{} folder) until the ``mastmon'' process successfully runs on the queue.

\end{itemize}


\subsubsection{queue\_commands.py}
\label{1_0_installation:queue-commands-py}
These queue commands will be used to submit ingredients to the queue and retrieve the job IDs and statuses of ingredients on the queue.
\begin{itemize}
\item {} 
For a custom platform, modify the \code{\textless{}MAST installation directory\textgreater{}/submit/platforms/\textless{}your custom platform\textgreater{}/queue\_commands.py} file.

\item {} 
Do not modify the \code{\textless{}MAST installation directory/submit/queue\_commands.py} file.

\end{itemize}

Modify the following python functions as necessary:
\begin{itemize}
\item {} 
\code{queue\_submission\_command}:
\begin{itemize}
\item {} 
This function should return the correct queue submission command,

\item {} 
For example, this function should return \code{qsub} on PBS/Torque, or \code{sbatch} on slurm.

\end{itemize}

\item {} 
\code{extract\_submitted\_jobid}:
\begin{itemize}
\item {} 
This function should parse the job ID, given the text that returns to screen when you submit a job.

\item {} 
For example, it should return \code{456789} as the jobid for the following job submission and resulting screen text:

\begin{Verbatim}[commandchars=\\\{\}]
login2.mycluster\PYGZdl{} sbatch submit.sh
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
          Welcome to the Supercomputer
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYGZhy{}\PYGZhy{}\PYGZgt{} Verifying valid submit host (login2)...OK
\PYGZhy{}\PYGZhy{}\PYGZgt{} Verifying valid jobname...OK
\PYGZhy{}\PYGZhy{}\PYGZgt{} Enforcing max jobs per user...OK
\PYGZhy{}\PYGZhy{}\PYGZgt{} Verifying job request is within current queue limits...OK
Submitted batch job 456789
\end{Verbatim}

\item {} 
On a different cluster, it would return \code{456789} as the jobid for the following submission and resulting screen text:

\begin{Verbatim}[commandchars=\\\{\}]
[user1@mycluster test\PYGZus{}job]\PYGZdl{} qsub submit.sh
456789.mycluster.abcd.univ.edu
\end{Verbatim}

\end{itemize}

\item {} 
\code{queue\_snap\_command}:
\begin{itemize}
\item {} 
This function should show a summary of your current submitted jobs, which we call the \code{queue\_snapshot}.

\item {} 
For example, the queue snapshot command should return something like the following (platform-dependent):

\begin{Verbatim}[commandchars=\\\{\}]
JOBID   PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
456789      normal test1 user1 PD       0:00      4 (Resources)
456788      normal test2 user1 PD       0:00      1 (Resources)
456774      normal test3 user1  R    6:14:53      1 c123\PYGZhy{}124
456775      normal test4 user1  R    6:15:34      1 c125\PYGZhy{}126
\end{Verbatim}

\end{itemize}

\item {} 
\code{queue\_status\_from\_text}:
\begin{itemize}
\item {} 
This function should return the status of a specific job, based on the job number.

\item {} 
For example, job 456789 in the queue snapshot above, with status ``PD'' should correspond to a ``Q'' status (queued status) for MAST.

\item {} 
Job 456775 in the queue snapshot above, with status ``R'', should correspond to an ``R'' status (running status) for MAST.

\end{itemize}

\item {} 
\code{get\_approx\_job\_error\_file}:
\begin{itemize}
\item {} 
This function should return the name of the job error file.

\item {} 
The name of this file will depend on what is specified in \code{submit\_template.sh} and is usually something like \code{slurm.\textless{}jobnumber\textgreater{}} or \code{\textless{}jobname\textgreater{}.e\textless{}jobnumber\textgreater{}}

\end{itemize}

\end{itemize}


\section{Additional setup}
\label{1_0_installation:id3}\label{1_0_installation:additional-setup}
You may need to do any or all of the following:
\begin{itemize}
\item {} 
Identify the correct \code{mast\_exec} call for your system.
\begin{itemize}
\item {} 
For example, suppose you run VASP like this:

\begin{Verbatim}[commandchars=\\\{\}]
//opt/mpiexec/bin/mpiexec //share/apps/bin/vasp5.2\PYGZus{}par\PYGZus{}opt1
\end{Verbatim}

\item {} 
Then, in your input files, the \code{mast\_exec} keyword would be specified like this:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}exec //opt/mpiexec/bin/mpiexec //share/apps/bin/vasp5.2\PYGZus{}par\PYGZus{}opt1
\end{Verbatim}

\end{itemize}

\item {} 
Add additional lines to your user profile which allow you to run VASP, including any modules that need to be imported, additions to your library path, unlimiting the stack size, and so on.

\item {} 
Modify your text editor settings so that tabs become four spaces (or so that you have such an option readily available). This setting is very important to ensure that MAST can read the input file, especially the recipe section of the input file.
\begin{itemize}
\item {} 
If you use VIM (\code{vi}), add the following lines to your \code{\textasciitilde{}/.vimrc} file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdq{} VIM settings for python in a group below:
set tabstop=4
set shiftwidth=4
set smarttab
set expandtab
set softtabstop=4
set autoindent
\end{Verbatim}

\end{itemize}

\end{itemize}

Once you have completed any additional setup and have identified what \code{mast\_exec} should be, go to {\hyperref[17_0_testmast::doc]{\emph{Trying out MAST}}}.


\chapter{Trying out MAST}
\label{17_0_testmast:trying-out-mast}\label{17_0_testmast::doc}\begin{enumerate}
\item {} 
Go to \code{\$HOME/MAST/examples} (or \code{\$WORK/MAST/examples} or a similar folder, if you moved the \code{\$HOME/MAST} folder from its default location.)

\item {} 
Select one of the examples. The fastest one is \code{simple\_optimization.inp}

\item {} 
Copy that file:

\begin{Verbatim}[commandchars=\\\{\}]
cp simple\PYGZus{}optimization.inp test.inp
\end{Verbatim}

\item {} 
Modify the test.inp file with the correct \code{mast\_exec}, \code{mast\_ppn}, \code{mast\_queue}, \code{mast\_walltime}, and other settings described in {\hyperref[3_0_inputfile::doc]{\emph{Input File}}}

\item {} 
Try to parse the input file, entering the following command as one line:

\begin{Verbatim}[commandchars=\\\{\}]
nice \PYGZhy{}n 19 mast \PYGZhy{}i test.inp
\end{Verbatim}
\begin{itemize}
\item {} 
The \code{nice -n 19} keeps this command low priority, since it is being run on the headnode (but it is not too intensive).

\item {} 
The \code{-i} signals to MAST that it is processing an input file.

\end{itemize}

\item {} 
Your \code{\$MAST\_SCRATCH} directory should now have a recipe directory in it.
\begin{itemize}
\item {} 
The recipe directory will have a name corresponding to the elements and the input file, and ending with a timestamp of YYYYMMDD''T''hhmmss.

\item {} 
The recipe directory will contain several subfolders, which are ingredient directories.

\end{itemize}

\item {} 
Go to that recipe directory.
\begin{itemize}
\item {} 
To see the input options:
\begin{itemize}
\item {} 
\code{cat input.inp} (should be identical to test.inp since no looping was used)
\begin{itemize}
\item {} 
Note that you can use other viewing commands, not just \code{cat}, but be careful not to edit any of these files.

\end{itemize}

\item {} 
\code{cat archive\_input\_options.txt} (should show Al instead of element X1)

\end{itemize}

\item {} 
To see information about the ingredient relationships MAST detected from the recipe template:
\begin{itemize}
\item {} 
\code{cat archive\_recipe\_plan.txt}

\item {} 
Look at the \code{\$personal\_recipe} section in the \code{input.inp} file

\end{itemize}

\item {} 
To see ingredient statuses at a glance:
\begin{itemize}
\item {} 
\code{cat status.txt}

\end{itemize}

\end{itemize}

\item {} 
Run mast once: \code{nice -n 19 mast}

\item {} 
You should see a ``mastmon'' job appear on the queue specified in \code{\$MAST\_CONTROL/mastmon\_submit.sh}

\item {} 
MAST should have detected that the first ingredient was ready to run, so when that process disappears, run mast again: \code{nice -n 19 mast}

\item {} 
Now you should see \code{perfect\_opt1} appear on the queue.

\item {} 
\code{status.txt} in the recipe directory in \code{\$MAST\_SCRATCH} should show that \code{perfect\_opt1} has a status of ``Proceed to Queue'', or ``P''.

\item {} 
When the queued \code{perfect\_opt1} job starts running, you should be able to see output files inside \code{\$MAST\_SCRATCH/\textless{}recipe directory\textgreater{}/perfect\_opt1}

\item {} 
If you forgot some step above, or you encounter some errors, remove the recipe folder from \code{\$MAST\_SCRATCH} and start again from the beginning of this section.

\item {} 
The \code{\$MAST\_CONTROL} folder gives you error messages and other information. See {\hyperref[5_0_runningmast::doc]{\emph{Running MAST}}} for tips.

\end{enumerate}


\chapter{Input File}
\label{3_0_inputfile::doc}\label{3_0_inputfile:input-file}
When you use the command \code{mast -i \textless{}inputfile\textgreater{}.inp}, MAST does the following:
\begin{itemize}
\item {} 
Reads the input file

\item {} 
Creates a recipe directory in \code{\$MAST\_SCRATCH}

\item {} 
Creates the ingredient directories under that recipe directory

\item {} 
Creates all the necessary metadata.txt files for that recipe and its ingredients.

\end{itemize}

MAST will then copy the input file into that recipe directory, as \code{input.inp}.

MAST will refer to this recipe-local \code{input.inp} file for all subsequent contact with the recipe.


\section{General structure of the input file}
\label{3_0_inputfile:general-structure-of-the-input-file}
The input file has many sections. Sections are denoted by \code{\$\textless{}section name\textgreater{}} and \code{\$end}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}section

section\PYGZus{}text
section\PYGZus{}keyword keyword\PYGZus{}value

\PYGZdl{}end
\end{Verbatim}

Within each section there may also be subsections, with keywords and values.
Subsections are denoted by \code{begin \textless{}subsection name\textgreater{}} and \code{end}.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}section

section\PYGZus{}text
section\PYGZus{}keyword keyword\PYGZus{}value

begin subsection
subsection\PYGZus{}text
subsection\PYGZus{}keyword subsection\PYGZus{}keyword\PYGZus{}value
end

\PYGZdl{}end
\end{Verbatim}
\begin{itemize}
\item {} 
Comments in the input file are allowed only as separate lines, starting with the \# sign.

\item {} 
A comment may not be appended to a line.

\end{itemize}


\section{Sections of the input file}
\label{3_0_inputfile:sections-of-the-input-file}
See {\hyperref[3_1_inputsections::doc]{\emph{Sections of the Input File}}}


\section{Looping in the input file}
\label{3_0_inputfile:looping-in-the-input-file}
If special looping tags are present in the input file, MAST can read in a single input file and create several permutated recipes in \code{\$MAST\_SCRATCH}.

The looping tag \code{indeploop} may be used to create combinatorial permutations.
\begin{itemize}
\item {} 
\code{indeploop} may be used once at the beginning of a line (that is not a section or subsection header or ``end'' line).

\item {} 
\code{indeploop} may be used multiple times in an input file.

\end{itemize}

When \code{indeploop} is present at the beginning of the line, input file permutations will be created depending on the values in parentheses.

\begin{Verbatim}[commandchars=\\\{\}]
indeploop keyword1 (k1value1,k1value2)
\end{Verbatim}

The previous line would create two input files and corresponding recipes.
On the line that used to have \code{indeploop} on it, one input file would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 k1value1
\end{Verbatim}

The other input file would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 l1value2
\end{Verbatim}

If indeploop tags are present multiple times in the recipe, input files are created combinatorially:

\begin{Verbatim}[commandchars=\\\{\}]
indeploop keyword1 (k1value1,k1value2)
indeploop keyword2 (k2value1,k2value2)
\end{Verbatim}

The previous two lines in an input file would create four input files and corresponding recipes.
One input file would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 k1value1
keyword2 k2value1
\end{Verbatim}

Another would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 k1value1
keyword2 k2value2
\end{Verbatim}

A third would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 k1value2
kewyord2 k2value1
\end{Verbatim}

A fourth would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 k1value2
keyword2 k2value2
\end{Verbatim}

Sometimes, instead of combinatorial looping, some loops are meant to go together. In this case, the \code{pegloop1} and \code{pegloop2} tags may be used.
\begin{itemize}
\item {} 
There are only two pegged looping tags allowed, \code{pegloop1} and \code{pegloop2}.

\item {} 
Each tag may be used only once on a line.

\item {} 
Each tag may be used on multiple lines.

\end{itemize}

Every line that starts with \code{pegloop1} (the same will apply for \code{pegloop2}) will loop over keyword values, much like \code{indeploop}. However, the point of the pegged loops is to have two or more keywords loop together.

For example:

\begin{Verbatim}[commandchars=\\\{\}]
pegloop1 keyword1 (k1value1,k1value2)
pegloop1 keyword2 (k2value1,k2value2)
\end{Verbatim}

Using the \code{pegloop1} tag, the lines above would not produce four input files and corresponding recipes, as they would when using the \code{indeploop} tag. Instead, they would produce only two input files and corresponding recipes.

One input file would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 k1value1
keyword2 k2value1
\end{Verbatim}

The other input file would have:

\begin{Verbatim}[commandchars=\\\{\}]
keyword1 k1value2
keyword2 k2value2
\end{Verbatim}

The number of items in parentheses should be equal for all instances of the \code{pegloop1} (or, separately, the \code{pegloop2}) tag.

\code{pegloop1}, \code{pegloop2}, and all instances of \code{indeploop} will work combinatorially with each other.

Complex example (for looping only - many other necessary lines in the input file are skipped):

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}mast
pegloop1 system\PYGZus{}name (strain1,strain2,strain3)
\PYGZdl{}end

\PYGZdl{}structure
begin lattice
pegloop1 (3,4,5) 0 0
pegloop1 0 (3,4,5) 0
pegloop1 0 0 (3,4,5)
end

begin elementmap
pegloop2 X1 (Cr,Mn)
end
\PYGZdl{}end

\PYGZdl{}ingredients
begin ingredients\PYGZus{}global
indeploop mast\PYGZus{}xc (pw91,pbe)
LDAUJ 1
pegloop2 LDAUU (4.5,5)
end
\PYGZdl{}end
\end{Verbatim}

The above example would create 3*2*2 = 12 input files and corresponding recipes. The input file for the one of the recipes would look like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}mast
system\PYGZus{}name strain2
\PYGZdl{}end

\PYGZdl{}structure
begin lattice
4 0 0
0 4 0
0 0 4
end

begin elementmap
X1 Mn
end
\PYGZdl{}end

\PYGZdl{}ingredients
begin ingredients\PYGZus{}global
indeploop mast\PYGZus{}xc pbe
LDAUJ 1
LDAUU 5
end
\PYGZdl{}end
\end{Verbatim}


\chapter{Sections of the Input File}
\label{3_1_inputsections:sections-of-the-input-file}\label{3_1_inputsections::doc}

\section{The MAST section}
\label{3_1_0_mast::doc}\label{3_1_0_mast:the-mast-section}
The \code{\$mast} section contains this keyword:

\textbf{system\_name}: Specify a single descriptive word here.

This keyword will become part of the recipe directory's name, and allow you to spot the recipe more easily in the \code{\$MAST\_SCRATCH} directory.

This keyword comes in handy with pegged looping, in order to help you identify loops.
\begin{itemize}
\item {} 
Loops are otherwise differentiated by elements, if you were looping over elements, or simply by a 1-second timestamp difference.

\end{itemize}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}mast
system\PYGZus{}name epitaxialstrain
\PYGZdl{}end
\end{Verbatim}

Example for pegged loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}mast
pegloop1 system\PYGZus{}name (strain1,strain2,strain3)
\PYGZdl{}end
\end{Verbatim}


\section{The Structure section}
\label{3_1_1_structure:the-structure-section}\label{3_1_1_structure::doc}
The \code{\$structure} section contains the coordinate type, coordinates, and lattice, or, optionally, the name of a structure file (either CIF or VASP POSCAR-type).


\subsection{Structure by file}
\label{3_1_1_structure:structure-by-file}
Using the keyword \code{posfile}, a VASP POSCAR-type file or a CIF file can be inserted here in this section:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}structure
posfile POSCAR\PYGZus{}fcc
\PYGZdl{}end
\end{Verbatim}

The file should be located in the same directory as the input file at the time you call MAST, and should not be moved until the recipe is complete.

A CIF file should end with .cif.

A POSCAR-type filename must start with \code{POSCAR\_} or \code{CONTCAR\_} in order for pymatgen to recognize it. The elements will be obtained from the POSCAR unless you also have a POTCAR in the directory, in which case, check your output carefully because the elements might be given by the POTCAR instead, no matter what elements are written in the POSCAR file.


\subsection{Structure by specification}
\label{3_1_1_structure:structure-by-specification}
To specify a structure, use the following subsections:

\textbf{coord\_type}: This keyword specifies fractional or cartesian coordinates. Only fractional coordinates have been thoroughly tested with most MAST features.

\textbf{lattice}: The lattice subsection specifies lattice basis vectors on a cartesian coordinate system.

\textbf{elementmap}: The elementmap subsection allows you to create a generic lattice and interchange other elements onto it. This is useful when looping over other elements (discussed in {\hyperref[3_0_inputfile::doc]{\emph{Input File}}}).

The elementmap subsection works in conjunction with the coordinates subsection.

\textbf{coordinates}: The coordinates subsection specifies the coordinates in order.

Fractional coordinates are fractional along each lattice basis vector, e.g. .0.5 0 0. describes a position 0.5 (halfway) along the first lattice basis vector.

Each fractional coordinate must be preceded by either an element symbol or an X\# symbol corresponding to the symbols assigned in the elementmap section.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
begin \PYGZdl{}structure

coord\PYGZus{}type fractional

begin lattice
6.0 0.0 0.0
0.0 6.0 0.0
0.0 0.0 6.0
end

begin elementmap
X1 Ga
X2 As
end

begin coordinates
X1 0.000000 0.000000 0.000000
X1 0.500000 0.500000 0.000000
X1 0.000000 0.500000 0.500000
X1 0.500000 0.000000 0.500000
X2 0.250000 0.250000 0.250000
X2 0.750000 0.750000 0.250000
X2 0.250000 0.750000 0.750000
X2 0.750000 0.250000 0.750000
end

\PYGZdl{}end
\end{Verbatim}


\subsection{Finite-size scaling}
\label{3_1_1_structure:finite-size-scaling}
Finite size scaling is supported with a special ``scaling'' subsection.

Defect positions will be automatically scaled.
\begin{itemize}
\item {} 
For example, \code{0.25 0.0 0.0} in the original supercell would become \code{0.125 0.0 0.0} in a 2x1x1 cell.

\end{itemize}

Special notes:
\begin{itemize}
\item {} 
{\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}} should include an ``inducescaling'' ingredient with a \code{mast\_run\_method} of \code{run\_scale}

\item {} 
{\hyperref[3_1_3_recipe::doc]{\emph{The Recipe section}}} should include \code{inducescaling\_\textless{}S\textgreater{}} and \code{defect\_\textless{}S\textgreater{}} ingredients.
\begin{itemize}
\item {} 
The ``\textless{}S\textgreater{}'' tags will correspond to the scaling sizes and labels.

\end{itemize}

\end{itemize}

The scaling section has the syntax:
\begin{itemize}
\item {} 
Scaling matrix of integers \code{{[}M, N, P{]}} or \code{{[}M1 M2 M3, N1 N2 N3, P1 P2 P3{]}}

\item {} 
Kpoint mesh in the form \code{QxRxS}

\item {} 
Kpoint mesh type, M for Monkhorst-Pack and G for Gamma-point centered

\item {} 
(Optional) Kpoint mesh shift, in floats, e.g. \code{0.1 0.2 0.3}

\item {} 
(Optional) Label, in the form \code{label=\textless{}labelname\textgreater{}}

\end{itemize}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
begin scaling
[1 0 0,0 1 0, 0 0 1] 4x4x4 M label=1x1x1
[2 0 0,0 2 0, 0 0 1] 2x2x4 M label=2x2x1
[2 0 0,0 2 0, 0 0 2] 2x2x2 M label=2x2x2
[3 0 0,0 3 0, 0 0 3] 1x1x1 M label=3x3x3
end
\end{Verbatim}

In order to figure out which scaling sizes to use for finite-size scaling, MAST includes a Madelung potential utility.

This utility generates a distribution of cell sizes for best scaling, according to the method in:

\begin{Verbatim}[commandchars=\\\{\}]
Hine, N. D. M., Frensch, K., Foulkes, W. M. C. \PYGZam{} Finnis, M. W. Supercell size scaling of density functional theory formation energies of charged defects. Physical Review B 79, 13, doi:10.1103/PhysRevB.79.024112 (2009).
\end{Verbatim}

Run this utility as follows in order to generate a cut-and-paste for the scaling section.

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}finite\PYGZus{}size\PYGZus{}scaling\PYGZus{}sizes perfDir defDir minDefDist maxNumAtoms numStructAsked
\end{Verbatim}
\begin{itemize}
\item {} 
\textbf{perfDir}: perfect primordial (small) cell directory, which should already have run and include VASP CONTCAR, OSZICAR, etc. files.

\item {} 
\textbf{defDir}: defected primordial cell directory, which should already have run and include VASP CONTCAR, OSZICAR, etc. files.

\item {} 
\textbf{minDefDist} (default 3): minimum defect-defect distance between periodic images, in Angstroms.

\item {} 
\textbf{maxNumAtoms} (default 600): maximum number of atoms for supercell size evaluations

\item {} 
\textbf{numStructAsked} (default 5): number of structures to return in the distribution

\item {} 
Note that you will have to manually adjust the kpoint mesh in your cut-and-paste.

\end{itemize}


\section{The Ingredients section}
\label{3_1_2_ingredients::doc}\label{3_1_2_ingredients:the-ingredients-section}
The \code{\$ingredients} section contains a section for global ingredient keywords and then a section for each \textbf{ingredient type}.

Each ingredient type in the recipe should have a subsection denoted by \code{begin \textless{}ingredient type\textgreater{}}.

Example \code{\$ingredients} section:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}ingredients

begin ingredients\PYGZus{}global
keyword1 k1value1
end

begin ingredient\PYGZus{}type1
keyword1 k1value2
keyword2 k2value1
end

begin ingredient\PYGZus{}type2
keyword2 k2value2
end

\PYGZdl{}end
\end{Verbatim}

Program-specific keywords such as VASP INCAR keywords are included in these sections. All other keywords are prefaced with \code{mast\_}.

If there are no changes from the ingredients\_global section, just add an empty subsection for that ingredient type:

\begin{Verbatim}[commandchars=\\\{\}]
begin ingredient\PYGZus{}type
end
\end{Verbatim}

For a specific ingredient type, if a keyword is not specified in that ingredient type's subsection but is specified in the \textbf{ingredients\_global} subsection, then, the value for that keyword will be taken from ingredients\_global.
\begin{itemize}
\item {} 
In the example above, \code{ingredient\_type2} would inherit \code{keyword1 k1value1} from ingredients\_global.

\end{itemize}


\subsection{Program-specific keywords}
\label{3_1_2_ingredients:program-specific-keywords}
VASP keywords such as \code{IBRION}, \code{ISIF}, \code{LCHARG}, \code{LWAVE}, and so on, can be specified under each ingredient type in the \code{\$ingredients} section of the input file.

Such program-specific keywords are only allowed if they are listed in the program-specific file located in the \code{\textless{}MAST installation directory\textgreater{}/MAST/ingredients/programkeys/} folder, for example, \code{\textless{}MAST installation directory\textgreater{}/MAST/ingredients/programkeys/vasp\_allowed\_keywords.py}.

These program-specific keywords will be turned into uppercase keywords. The values will not change case, and should be given in the case required by the program. For example, \code{lwave False} will be translated into \code{LWAVE False} in the VASP INCAR file.

One exception for VASP keywords is the \code{IMAGES} keyword, which signals a nudged elastic band run, and should instead be set in the \code{\$neb} section of the input file.

For VASP ingredients, please include

\begin{Verbatim}[commandchars=\\\{\}]
lcharg False
lwave False
\end{Verbatim}

in your ingredient global keywords in order to avoid writing the large VASP files CHGCAR and WAVECAR, unless you really need these files.


\subsection{Special MAST keywords}
\label{3_1_2_ingredients:special-mast-keywords}
Any keyword that starts with \code{mast\_} is considered a special keyword utilized by MAST and will not be written into the VASP INCAR file or any custom input file.


\subsubsection{Submission script keywords}
\label{3_1_2_ingredients:submission-script-keywords}
The following queue submission keywords are platform-dependent and are used along to create the submission script (see {\hyperref[1_0_installation::doc]{\emph{Installation}}}).

\textbf{mast\_exec}: The command used in the submission script to execute the program. Note that this is a specific command rather than the class of program, given in \code{mast\_program}, and it should include any MPI commands.

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}exec //opt/mpiexec/bin/mpiexec \PYGZti{}/bin/vasp\PYGZus{}5.2
\end{Verbatim}

\textbf{mast\_nodes}: The number of nodes requested.

\textbf{mast\_ppn}: The number of processors per node requested.

\textbf{mast\_queue}: The queue requested.

\textbf{mast\_walltime}: The walltime requested, in whole number of hours

\textbf{mast\_memory}: The memory per processor requested.


\subsubsection{MAST control flow keywords}
\label{3_1_2_ingredients:mast-control-flow-keywords}
\textbf{mast\_program}: Specify which program to run (\code{vasp}, \code{vasp\_neb}, or \code{None} for a generic program, are currently supported)

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}program vasp
\end{Verbatim}
\begin{itemize}
\item {} 
This keyword must be in lowercase

\end{itemize}

\textbf{mast\_frozen\_seconds}: A number of seconds before a job is considered frozen, if its output file has not been updated within this amount of time. If not set, 21000 seconds is used.

\textbf{mast\_auto\_correct}: Specify whether mast should automatically correct errors.
\begin{itemize}
\item {} 
The default is True, so if this keyword is set to True, or if this keyword is not specified at all, then MAST will attempt to find errors, automatically correct the errors, and resubmit the ingredient.

\item {} 
If set to False, MAST will attempt to find errors, then write them into a \code{MAST\_ERROR} file in the recipe folder, logging both the error-containing ingredient and the nature of the error, but not taking any corrective actions. The recipe will be skipped in all subsequent MAST runs until the \code{MAST\_ERROR} file is manually deleted by the user.

\end{itemize}


\subsubsection{VASP-specific keywords}
\label{3_1_2_ingredients:vasp-specific-keywords}
\textbf{mast\_kpoints}: Specify k-point instructions in the form of kpoints along lattice vectors a, b, and c, and then a designation M for Monkhorst-Pack or G for Gamma-centered.

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}kpoints = 3x3x3 G
\end{Verbatim}
\begin{itemize}
\item {} 
Either this keyword or \code{mast\_kpoint\_density} is required for VASP calculations.

\end{itemize}

\textbf{mast\_kpoint\_density}: A number for the desired kpoint mesh density.
\begin{itemize}
\item {} 
Only works with \code{mast\_write\_method} of \code{write\_singlerun\_automesh}

\item {} 
Either this keyword or \code{mast\_kpoints} is required for VASP calculations.

\end{itemize}

\textbf{mast\_pp\_setup}: Specify which pseudopotential goes to which element:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}pp\PYGZus{}setup La=La Mn=Mn\PYGZus{}pv O=O\PYGZus{}s
\end{Verbatim}

\textbf{mast\_xc}: Specify an exchange correlation functional; for VASP, follow the conventions of pymatgen (e.g. pw91, pbe)
\begin{itemize}
\item {} 
This keyword is required for VASP calculations.

\end{itemize}

\textbf{mast\_multiplyencut}: Specify a number with which to multiply the maximum ENCUT value of the pseudopotentials. Volume relaxations in VASP often take 1.5; otherwise 1.25 is sufficient.
\begin{itemize}
\item {} 
Default is 1.5

\item {} 
If \code{encut} is given as a program keyword, then that value will be used and \code{mast\_multiplyencut} should have no effect

\end{itemize}

\textbf{mast\_setmagmom}: Specify a string to use for setting the initial magnetic moment. A short string will result in multipliers. For example, \code{mast\_setmagmom 1 5 1} will produce \code{2*1 2*5 8*1} for a 12-atom unit cell with 2A, 2B, and 8C atoms. A string of the number of atoms in the \code{POSCAR} file will be printed as entered, for example, \code{mast\_setmagmom 1 -1 1 -1 1 -1 1 -1}.

\textbf{mast\_charge}: Specify the charge on the system (total system)
\begin{itemize}
\item {} 
-1 charge means the ADDITION of one electron. For example, O2- has two more electrons than O neutral.

\item {} 
A positive charge is the REMOVAL of electrons. For example, Na+ with a +1 charge has one FEWER electron than Na neutral.

\end{itemize}

\textbf{mast\_coordinates}: For a non-NEB calculation, allows you to specify a single POSCAR-type of CIF structure file which corresponds to the relaxed fractional coordinates at which you would like to start this ingredient. ONLY the coordinates are used. The lattice parameters and elements are given by the \$structure section of the input file. The coordinates must be fractional coordinates.

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}coordinates POSCAR\PYGZus{}initialize
\end{Verbatim}
\begin{itemize}
\item {} 
For an NEB calculation, use a comma-delimited list of poscar files corresponding to the correct number of images. Put no spaces between the file names. Example for an NEB with 3 intermediate images:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}coordinates POSCAR\PYGZus{}im1,POSCAR\PYGZus{}im2,POSCAR\PYGZus{}im3
\end{Verbatim}

\item {} 
The structure files must be found in the directory from which the input file is being submitted when initially inputting the input file (e.g. the directory you are in when you run \code{mast -i test.inp}); once the \code{input.inp} file is created in the recipe directory, it will store a full path back to these poscar-type files.

\item {} 
This keyword cannot be used with programs other than VASP, cartesian coordinates, and special ingredients like inducedefect-type ingredients, whose write or run methods are different.

\end{itemize}


\subsubsection{Structure manipulation keywords}
\label{3_1_2_ingredients:structure-manipulation-keywords}
\textbf{mast\_strain}: Specify three numbers for multiplying the lattice parameters a, b, and c. Only works with \code{mast\_run\_method} of \code{run\_strain}

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}strain 1.01 1.03 0.98
\end{Verbatim}

This example will stretch the lattice along lattice vector a by 1\%, stretch the lattice along lattice vector b by 3\%, and compress the lattice along lattice vector c by 2\%


\subsubsection{mast\_xxx\_method keywords}
\label{3_1_2_ingredients:mast-xxx-method-keywords}
The following keywords have individual sections:

\textbf{mast\_write\_method}: Specifies what the ingredient should write out before running (e.g., create the INCAR)

\textbf{mast\_ready\_method}: Specifies how MAST can tell if the ingredient is ready to run (often, in addition to writing its own files, an ingredient must also wait for data from its parent ingredient(s)).

\textbf{mast\_run\_method}: Specifies what MAST should do to run the ingredient (e.g. submit a submission script to a queue, or perform some other action)

\textbf{mast\_complete\_method}: Specifies how MAST can tell if the ingredient is considered complete

\textbf{mast\_update\_children\_method}: Specifies what information an ingredient passes on to its children, and how it does so.

Specific available values for each keyword are given in the accompanying sections, and require no arguments, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}write\PYGZus{}method write\PYGZus{}singlerun
\end{Verbatim}

They depend on having an appropriate program set in \code{mast\_program}.

However, you may choose to specify arguments where available, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}complete\PYGZus{}method file\PYGZus{}has\PYGZus{}string myoutput \PYGZdq{}End of Execution\PYGZdq{}
\end{Verbatim}

You may also choose to specify multiple methods. These methods will be performed in the order listed. For \code{mast\_ready\_method} or \code{mast\_complete\_method}, all methods listed must return True in order for the ingredient to be considered ready or complete, respectively.
Use a semicolon to separate out the methods:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}complete\PYGZus{}method file\PYGZus{}has\PYGZus{}string myoutput \PYGZdq{}End of Execution\PYGZdq{}; file\PYGZus{}exists Parsed\PYGZus{}Structures
\end{Verbatim}

In the example above, the file ``myoutput'' must exist and contain the phrase ``End of Execution'', and the file ``Parsed\_Structures'' must exist, in order for the ingredient to be considered complete.

Update-children methods will always get the child name appended as the end of the argument string. For example,

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method copy\PYGZus{}file EndStructure BeginStructure
\end{Verbatim}

will copy the file EndStructure of the parent ingredient folder to a new file BeginStructure in the child ingredient folder. There is no separate argument denoting the child ingredient.

All arguments are passed as strings. Arguments in quotation marks are kept together.

Some common open-ended methods are:
\begin{itemize}
\item {} 
\textbf{file\_exists \textless{}filename\textgreater{}}

\item {} 
\textbf{file\_has\_string \textless{}filename\textgreater{} \textless{}string\textgreater{}}

\item {} 
\textbf{copy\_file \textless{}filename\textgreater{} \textless{}copy\_to\_filename\textgreater{}}

\item {} 
\textbf{softlink\_file \textless{}filename\textgreater{} \textless{}softlink\_to\_filename\textgreater{}}

\item {} 
\textbf{copy\_fullpath\_file \textless{}full path file name\textgreater{} \textless{}copy\_to\_filename\textgreater{}}: This method is for copying some system file like //home/user/some\_template, not an ingredient-specific file

\item {} 
\textbf{write\_ingred\_input\_file \textless{}filename\textgreater{} \textless{}allowed file\textgreater{} \textless{}uppercase keywords\textgreater{} \textless{}delimiter\textgreater{}}: The allowed file specifies an allowed keywords file name in \code{\textless{}MAST installation directory\textgreater{}/MAST/ingredients/programkeys}.
\begin{itemize}
\item {} 
Use ``all'' to put any non-mast keywords into the input file.

\item {} 
Use 1 to uppercase all keywords, or 0 to leave them as entered.

\item {} 
Leave off the delimiter argument in order to use a single space.

\item {} 
Examples:

\begin{Verbatim}[commandchars=\\\{\}]
write\PYGZus{}ingred\PYGZus{}input\PYGZus{}file input.txt all 0 =
write\PYGZus{}ingred\PYGZus{}input\PYGZus{}file input.txt phon\PYGZus{}allowed\PYGZus{}keys.py 1
\end{Verbatim}

\end{itemize}

\item {} 
\textbf{no\_setup}: Does nothing. Useful when you want to specifically specify doing nothing.

\item {} 
\textbf{no\_update}: Does nothing (but, does accept the child name it is given). Useful when you want to specify doing nothing for a child update step.

\item {} 
\textbf{run\_command: \textless{}command string, including all arguments\textgreater{}}: This method allows you to run a python script.
\begin{itemize}
\item {} 
The python script may take in only string-based arguments

\item {} 
Please stick to common text characters.

\item {} 
Example:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}run\PYGZus{}method run\PYGZus{}command \PYGZdq{}//home/user/myscripts/my\PYGZus{}custom\PYGZus{}parsing.py 25 0.01\PYGZdq{}
\end{Verbatim}

\item {} 
In the example above, the numbers 25 and 0.01 will actually be passed into sys.argv as a string.

\item {} 
This method is intended to allow you to run short custom scripts of your own creation, particularly for \code{mast\_write\_method} when setting up your ingredient.

\item {} \begin{description}
\item[{For long or complex execution steps where you want the output tracked separately, do not use this method. Instead, do the following in order to get your script submitted to the queue:}] \leavevmode
\#  Use \code{write\_submit\_script} in your \code{mast\_write\_method}, along with any other write methods
\#  Use \code{mast\_run\_method run\_singlerun}
\#  Put your script in the \code{mast\_exec} keyword

\end{description}

\end{itemize}

\end{itemize}


\subsubsection{mast\_write\_method keyword values}
\label{3_1_2_ingredients:mast-write-method-keyword-values}
\textbf{write\_singlerun}
\begin{itemize}
\item {} 
Write files for a single generic run.

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{write\_singlerun\_automesh}
\begin{itemize}
\item {} 
Write files for a single generic run.

\item {} 
Programs supported: vasp

\item {} 
Requires the \code{mast\_kpoint\_density} ingredient keyword

\end{itemize}

\textbf{write\_neb}
\begin{itemize}
\item {} 
Write an NEB ingredient. This method writes interpolated images to the appropriate folders, creating 00/01/.../0N directories.

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{write\_neb\_subfolders}
\begin{itemize}
\item {} 
Write static runs for an NEB, starting from a previous NEB, into image subfolders 01 to 0(N-1).

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{write\_phonon\_single}
\begin{itemize}
\item {} 
Write files for a phonon run.

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{write\_phonon\_multiple}
\begin{itemize}
\item {} 
Write a phonon run, where the frequency calculation for each atom and each direction is a separate run, using selective dynamics. CHGCAR and WAVECAR must have been given to the ingredient previously; these files will be softlinked into each subfolder.

\item {} 
Programs supported: vasp

\end{itemize}


\subsubsection{mast\_ready\_method keyword values}
\label{3_1_2_ingredients:mast-ready-method-keyword-values}
\textbf{ready\_singlerun}
\begin{itemize}
\item {} 
Checks that a single run is ready to run

\item {} 
Programs supported: vasp (either NEB or regular VASP run), phon

\end{itemize}

\textbf{ready\_defect}
\begin{itemize}
\item {} 
Checks that the ingredient has a structure file

\item {} 
Programs supported: vasp

\end{itemize}

\textbf{ready\_neb\_subfolders}
\begin{itemize}
\item {} 
Checks that each 01/.../0(N-1) subfolder is ready to run as its own separate calculation, following the ready\_singlerun criteria for each folder

\item {} 
This method is used for NEB static calculations rather than NEB calculations themselves.

\end{itemize}

\textbf{ready\_subfolders}
*  Checks that each subfolder is ready to run, following the ready\_singlerun criteria.
*  Generic
*  This method is used for calculations whose write method includes subfolders, and where each subfolder is a calculation, as in \code{write\_phonon\_multiple}.


\subsubsection{mast\_run\_method keyword values}
\label{3_1_2_ingredients:mast-run-method-keyword-values}
\textbf{run\_defect}
\begin{itemize}
\item {} 
Create a defect in the structure; not submitted to queue

\item {} 
Generic

\item {} 
Requires the \code{\$defects} section in the input file (see {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}).

\end{itemize}

\textbf{run\_singlerun}
\begin{itemize}
\item {} 
Submit a run to the queue.

\item {} 
Generic

\end{itemize}

\textbf{run\_neb\_subfolders}
\begin{itemize}
\item {} 
Run each 01/.../0(N-1) subfolder as run\_singlerun

\item {} 
Generic

\end{itemize}

\textbf{run\_subfolders}
\begin{itemize}
\item {} 
Run each subfolder as run\_singlerun

\item {} 
Generic

\end{itemize}

\textbf{run\_strain}
\begin{itemize}
\item {} 
Strain the structure; not submitted to queue

\item {} 
Generic

\item {} 
Requires the \code{mast\_strain} ingredient keyword

\end{itemize}

\textbf{run\_scale}
\begin{itemize}
\item {} 
Scale the structure (e.g. a 2-atom unit cell scaled by 2 becomes a 16-atom supercell)

\item {} 
Requires the \code{\$scaling} subsection in the input file (see {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}}).

\item {} 
Must not be run on the starting ingredient.

\end{itemize}


\subsubsection{mast\_complete\_method keyword values}
\label{3_1_2_ingredients:mast-complete-method-keyword-values}
\textbf{complete\_singlerun}
\begin{itemize}
\item {} 
Check if run is complete

\item {} 
Programs supported: vasp

\item {} 
Note that for VASP, the phrase \code{reached required accuracy} is checked for, as well as a \code{User time} in seconds. The exceptions are:
\begin{itemize}
\item {} 
NSW of 0, NSW of -1, or NSW not specified in the ingredients section keywords is taken as a static calculation, and .EDIFF is reached. is checked instead of .reached required accuracy.

\item {} 
IBRION of -1 is taken as a static calculation, and .EDIFF is  reached. is checked instead of .reached required accuracy.

\item {} 
IBRION of 0 is taken as an MD calculation, and only user time is checked

\item {} 
IBRION of 5, 6, 7, or 8 is taken as a phonon calculation, and only user time is checked

\end{itemize}

\end{itemize}

\textbf{complete\_neb\_subfolders}
\begin{itemize}
\item {} 
Check if all NEB subfolders 01/.../0(N-1) are complete, according to complete\_singlerun criteria.

\item {} 
This method is not for checking the completion of NEBs! An NEB ingredient should have \code{mast\_program vasp\_neb} and \code{mast\_complete\_method complete\_singlerun}.

\item {} 
An NEB static calculation, or a static calculation for each image, would use this keyword as \code{mast\_complete\_method complete\_neb\_subfolders} but have \code{mast\_program vasp} instead of vasp\_neb.

\end{itemize}

\textbf{complete\_subfolders}
\begin{itemize}
\item {} 
Check if all subfolders are complete, according to complete\_singlerun criteria.

\item {} 
Generic

\end{itemize}

\textbf{complete\_structure}
\begin{itemize}
\item {} 
Check if run has an output structure file written

\item {} 
Programs supported: vasp (looks for CONTCAR)

\end{itemize}


\subsubsection{mast\_update\_children\_method keyword values}
\label{3_1_2_ingredients:mast-update-children-method-keyword-values}
\textbf{give\_structure}
\begin{itemize}
\item {} 
Forward the relaxed structure

\item {} 
Programs supported: vasp (CONTCAR to POSCAR)

\end{itemize}

\textbf{give\_structure\_and\_energy\_to\_neb}
\begin{itemize}
\item {} 
Forward the relaxed structure and energy files

\item {} 
Programs supported: vasp (CONTCAR to POSCAR, and copy over OSZICAR)

\end{itemize}

\textbf{give\_neb\_structures\_to\_neb}
\begin{itemize}
\item {} 
Give NEB output images structures as the starting point image input structures in another NEB

\item {} 
Programs supported: vasp (01/.../0(N-1) CONTCAR files will be the child NEB ingredient.s starting 01/.../0(N-1) POSCAR files.

\end{itemize}

\textbf{give\_saddle\_structure}
\begin{itemize}
\item {} 
Forward the highest-energy structure of all subfolder structures

\item {} 
Programs supported: vasp

\end{itemize}


\subsubsection{Example Ingredients section}
\label{3_1_2_ingredients:example-ingredients-section}
Here is an example ingredients section:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}ingredients
begin ingredients\PYGZus{}global
mast\PYGZus{}program    vasp
mast\PYGZus{}nodes      1
mast\PYGZus{}multiplyencut 1.5
mast\PYGZus{}ppn        1
mast\PYGZus{}queue      default
mast\PYGZus{}exec       mpiexec //home/mayeshiba/bin/vasp.5.3.3\PYGZus{}vtst\PYGZus{}static
mast\PYGZus{}kpoints    2x2x2 M
mast\PYGZus{}xc PW91
isif 2
ibrion 2
nsw 191
ismear 1
sigma 0.2
lwave False
lcharg False
prec Accurate
mast\PYGZus{}program   vasp
mast\PYGZus{}write\PYGZus{}method           write\PYGZus{}singlerun
mast\PYGZus{}ready\PYGZus{}method           ready\PYGZus{}singlerun
mast\PYGZus{}run\PYGZus{}method             run\PYGZus{}singlerun
mast\PYGZus{}complete\PYGZus{}method        complete\PYGZus{}singlerun
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}structure
end

begin volrelax\PYGZus{}to\PYGZus{}singlerun
isif 3
end

begin singlerun\PYGZus{}to\PYGZus{}phonon
ibrion \PYGZhy{}1
nsw 0
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}structure\PYGZus{}and\PYGZus{}restart\PYGZus{}files
mast\PYGZus{}multiplyencut 1.25
lwave True
lcharge True
end

begin inducedefect
mast\PYGZus{}write\PYGZus{}method           no\PYGZus{}setup
mast\PYGZus{}ready\PYGZus{}method           ready\PYGZus{}defect
mast\PYGZus{}run\PYGZus{}method             run\PYGZus{}defect
mast\PYGZus{}complete\PYGZus{}method        complete\PYGZus{}structure
end

begin singlerun\PYGZus{}vac1
mast\PYGZus{}coordinates            POSCAR\PYGZus{}vac1
end

begin singlerun\PYGZus{}vac2
mast\PYGZus{}coordinates            POSCAR\PYGZus{}vac2
end

begin singlerun\PYGZus{}to\PYGZus{}neb
ibrion \PYGZhy{}1
nsw 0
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}structure\PYGZus{}and\PYGZus{}energy\PYGZus{}to\PYGZus{}neb
lwave True
lcharge True
end

begin neb\PYGZus{}to\PYGZus{}neb\PYGZus{}vac1\PYGZhy{}vac2
mast\PYGZus{}coordinates            POSCAR\PYGZus{}nebim1,POSCAR\PYGZus{}nebim2,POSCAR\PYGZus{}nebim3
mast\PYGZus{}write\PYGZus{}method           write\PYGZus{}neb
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}neb\PYGZus{}structures\PYGZus{}to\PYGZus{}neb
mast\PYGZus{}nodes                  3
mast\PYGZus{}kpoints                1x1x1 G
ibrion 1
potim 0.5
images 3
lclimb True
spring \PYGZhy{}5
end

begin neb\PYGZus{}to\PYGZus{}neb\PYGZus{}vac1\PYGZhy{}vac3
mast\PYGZus{}coordinates            POSCAR\PYGZus{}nebim1\PYGZus{}set2,POSCAR\PYGZus{}nebim2\PYGZus{}set2,POSCAR\PYGZus{}nebim3\PYGZus{}set2
mast\PYGZus{}write\PYGZus{}method           write\PYGZus{}neb
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}neb\PYGZus{}structures\PYGZus{}to\PYGZus{}neb
mast\PYGZus{}nodes                  3
mast\PYGZus{}kpoints                1x1x1 G
ibrion 1
potim 0.5
images 3
lclimb True
spring \PYGZhy{}5
end

begin neb\PYGZus{}to\PYGZus{}nebstat
mast\PYGZus{}write\PYGZus{}method           write\PYGZus{}neb
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}neb\PYGZus{}structures\PYGZus{}to\PYGZus{}neb
mast\PYGZus{}nodes                  3
ibrion 1
potim 0.5
images 3
lclimb True
spring \PYGZhy{}5
end

begin nebstat\PYGZus{}to\PYGZus{}nebphonon
ibrion \PYGZhy{}1
nsw 0
mast\PYGZus{}write\PYGZus{}method           write\PYGZus{}neb\PYGZus{}subfolders
mast\PYGZus{}ready\PYGZus{}method           ready\PYGZus{}neb\PYGZus{}subfolders
mast\PYGZus{}run\PYGZus{}method             run\PYGZus{}neb\PYGZus{}subfolders
mast\PYGZus{}complete\PYGZus{}method        complete\PYGZus{}neb\PYGZus{}subfolders
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}saddle\PYGZus{}structure
end

begin phonon\PYGZus{}to\PYGZus{}phononparse
mast\PYGZus{}write\PYGZus{}method           write\PYGZus{}phonon\PYGZus{}multiple
mast\PYGZus{}ready\PYGZus{}method           ready\PYGZus{}subfolders
mast\PYGZus{}run\PYGZus{}method             run\PYGZus{}subfolders
mast\PYGZus{}complete\PYGZus{}method        complete\PYGZus{}subfolders
mast\PYGZus{}update\PYGZus{}children\PYGZus{}method  give\PYGZus{}phonon\PYGZus{}multiple\PYGZus{}forces\PYGZus{}and\PYGZus{}displacements
ibrion 5
nfree 2
potim 0.01
istart 1
icharg 1
end

\PYGZdl{}end
\end{Verbatim}


\section{The Recipe section}
\label{3_1_3_recipe:the-recipe-section}\label{3_1_3_recipe::doc}
The \code{\$recipe} section of the input file contains information about how the ingredients are related to each other.
\begin{itemize}
\item {} 
This information complements the \code{mast\_update\_children\_method} keyword given for each ingredient.

\end{itemize}

An ingredient in the recipe is referred to by:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}ingredient name\PYGZgt{} (ingredient type in \PYGZdl{}ingredients section)
\end{Verbatim}

For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{perfect\PYGZus{}opt1} \PYG{p}{(}\PYG{n}{lowmesh\PYGZus{}relaxation}\PYG{p}{)}
\end{Verbatim}

If no ingredient type is given, then only settings from the ingredients\_global ingredient type of the input file will be used.

The ingredient name has some restrictions:
\begin{itemize}
\item {} 
For a simple workflow, the ingredient name may be fully and arbitrarily specified for the user.

\item {} 
In most complex workflows, however, tags may be used as shortcuts to ingredient names. These tags will be filled in from information in the input file.
\begin{itemize}
\item {} 
\textbf{\textless{}S\textgreater{}}: The \code{scaling} subsection of {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}}

\item {} 
\textbf{\textless{}N\textgreater{}}: {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}

\item {} 
\textbf{\textless{}Q\textgreater{}}: The \code{charge} keyword in {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}

\item {} 
\textbf{\textless{}P\textgreater{}}: The \code{phonon} keyword in {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}} and \emph{3\_1\_6\_neb}

\item {} 
\textbf{\textless{}B\textgreater{}, \textless{}E\textgreater{}, \textless{}B-E\textgreater{}}: {\hyperref[3_1_6_neb::doc]{\emph{The NEB section}}}

\item {} 
The filled-in tags will be evident in {\hyperref[3_1_4_personalrecipe::doc]{\emph{The Personal Recipe section}}} of the \code{input.inp} file in the recipe directory, once MAST has read the input file and set up the recipe directory.

\end{itemize}

\item {} 
When tags are used, certain conventions must be followed:
\begin{itemize}
\item {} 
Inducing scaling must use an \code{inducescaling\_\textless{}S\textgreater{}} ingredient.

\item {} 
Inducing defects must use an \code{inducedefect\_\textless{}N\textgreater{}} or \code{inducedefect\_\textless{}S\textgreater{}\_\textless{}N\textgreater{}} ingredient.

\item {} 
Defects must start with \code{defect}, and if tags are used, they must follow the order \textless{}S\textgreater{}, \textless{}N, B, or E\textgreater{}, \textless{}Q\textgreater{}, depending on which tags are used.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{defect\PYGZus{}}\PYG{o}{\PYGZlt{}}\PYG{n}{S}\PYG{o}{\PYGZgt{}}\PYG{n}{\PYGZus{}}\PYG{o}{\PYGZlt{}}\PYG{n}{N}\PYG{o}{\PYGZgt{}}\PYG{n}{\PYGZus{}}\PYG{o}{\PYGZlt{}}\PYG{n}{Q}\PYG{o}{\PYGZgt{}}\PYG{n}{\PYGZus{}arbitrarysuffix}
\end{Verbatim}

\item {} 
Phonons must start with \code{phonon}, and if tags are used, they must follow the order \textless{}S\textgreater{}, \textless{}N or B-E\textgreater{}, \textless{}Q\textgreater{}, \textless{}P\textgreater{}

\item {} 
NEBs must start with \code{neb}, and if tags are used, they must follow the order \textless{}S\textgreater{}, \textless{}B-E\textgreater{}, \textless{}Q\textgreater{}

\end{itemize}

\end{itemize}

\textbf{Important: when creating or editing recipes, do not use the Tab key. Instead, use 4 spaces to indent.}
\begin{itemize}
\item {} 
See {\hyperref[1_0_installation::doc]{\emph{Installation}}} for setting up text editors.

\item {} 
Also make sure that the recipe you are working with has not somehow been converted to tabs.

\end{itemize}


\subsection{Syntax}
\label{3_1_3_recipe:syntax}
Each indentation level marks a parent-child relationship.:

\begin{Verbatim}[commandchars=\\\{\}]
perfect\PYGZus{}opt1 (volrelax\PYGZus{}lowmesh)
    perfect\PYGZus{}opt2
        perfect\PYGZus{}opt3
\end{Verbatim}

The ingredient type of an ingredient is specified in parentheses after the ingredient.

The ingredient type should correspond to ingredient subsections within {\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}}. If no ingredient type is specified, the ingredient gets all default values from the ingredients\_global subsection.

In the recipe:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{perfect\PYGZus{}opt1} \PYG{p}{(}\PYG{n}{volrelax\PYGZus{}lowmesh}\PYG{p}{)}
\end{Verbatim}

In the input file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}ingredients

begin volrelax\PYGZus{}lowmesh
mast\PYGZus{}run\PYGZus{}method run\PYGZus{}singlerun
...
end

\PYGZdl{}end
\end{Verbatim}

If the parent needs to update several children in different ways, create new trees where the originating parent is the same parent name, but with a different ingredient type:

\begin{Verbatim}[commandchars=\\\{\}]
perfect\PYGZus{}stat (stat\PYGZus{}to\PYGZus{}defect)
    defect\PYGZus{}opt
perfect\PYGZus{}stat (stat\PYGZus{}to\PYGZus{}phonon)
    phonon\PYGZus{}opt1
\end{Verbatim}
\begin{itemize}
\item {} 
Those different ingredient types should have different mast\_update\_children\_method keyword values in the input file.

\item {} 
They should have all the same other keywords.

\end{itemize}

If two children need to be the parent of one ingredient, also create a new tree:

\begin{Verbatim}[commandchars=\\\{\}]
perfect\PYGZus{}stat
    defect\PYGZus{}1\PYGZus{}opt
    defect\PYGZus{}2\PYGZus{}opt
defect\PYGZus{}1\PYGZus{}opt, defect\PYGZus{}2\PYGZus{}opt
    neb\PYGZus{}1\PYGZhy{}2\PYGZus{}opt
\end{Verbatim}

Parent-child relationships are name-based, and the name must also include correct formats for size-scaling labels \textless{}S\textgreater{}, defect labels \textless{}N, B, or E\textgreater{}, neb labels \textless{}B-E\textgreater{}, charge labels \textless{}Q\textgreater{}, and phonon labels \textless{}P\textgreater{}.
\begin{itemize}
\item {} 
These names are important for following the tree structure and for setting the metadata file.

\item {} 
Parent-child relationships are specified by these particular folder names.

\item {} 
Some post-processing utilities may also rely on folder names.

\end{itemize}

\textbf{The \textless{}S\textgreater{} tag}
The \textless{}S\textgreater{} tag will correspond to labels in the \code{scaling} subsection of {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}}.

\textbf{The \textless{}N\textgreater{}, \textless{}B\textgreater{}, \textless{}E\textgreater{}, and \textless{}B-E\textgreater{} tags}
For defects, the \textless{}N\textgreater{} tag will correspond to labels in {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}.

The same labels will be matched up and should be used as \textless{}B\textgreater{} and \textless{}E\textgreater{} labels (beginning and ending states) to correspond with NEBs, which are labeled \textless{}B-E\textgreater{}.

The NEB labels will correspond to labels in {\hyperref[3_1_6_neb::doc]{\emph{The NEB section}}}

NEB label names must match up exactly with defect label names. For example, defect\_vac1 and defect\_vac2 must match up with neb\_vac1-vac2.

Use \textless{}N\textgreater{} in a recipe unless specifying that a defect is a parent of an NEB, in which case use \textless{}B\textgreater{} or \textless{}E\textgreater{}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}begin\PYGZcb{}
defect\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}opt1 (relax)
    defect\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}stat (static)
\PYGZob{}end\PYGZcb{}

\PYGZob{}begin\PYGZcb{}
defect\PYGZus{}\PYGZlt{}B\PYGZgt{}\PYGZus{}stat (static\PYGZus{}to\PYGZus{}neb), defect\PYGZus{}\PYGZlt{}E\PYGZgt{}\PYGZus{}stat (static\PYGZus{}to\PYGZus{}neb)
    neb\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}opt1 (neb)
\PYGZob{}end\PYGZcb{}
\end{Verbatim}

\textbf{The \textless{}Q\textgreater{} tag}
The \textless{}Q\textgreater{} tag will correspond to charges given in {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}.
\begin{itemize}
\item {} 
Charges are given as
\begin{itemize}
\item {} 
q=p0 for no charge

\item {} 
q=nX for negative charge X (addition of electrons)

\item {} 
q=pX for positive charge X (removal of electrons)

\end{itemize}

\end{itemize}

\textbf{\{begin\} and \{end\}}

In the recipe, \{begin\} and \{end\} will loop over, match up, and fill in scaling labels \textless{}S\textgreater{}, defect labels \textless{}N, B, and E\textgreater{}, NEB labels \textless{}B-E\textgreater{}, charges \textless{}Q\textgreater{}, and phonons \textless{}P\textgreater{}
\begin{itemize}
\item {} 
Only charges in the charge range of both the \textless{}B\textgreater{} and \textless{}E\textgreater{} defect parents of an NEB will produce an charged NEB.

\item {} 
Use a new \{begin\} and \{end\} when you have a new tree branch or unindentation in the recipe that switches between \textless{}N\textgreater{} and \textless{}B\textgreater{} or \textless{}E\textgreater{}

\item {} 
Note that defect endpoints need to be the parents of all NEB optimizations and NEB static calculations. Therefore, the endpoint-neb parent-child block may look like the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}begin\PYGZcb{}
defect\PYGZus{}\PYGZlt{}B\PYGZgt{}\PYGZus{}stat (static\PYGZus{}to\PYGZus{}neb), defect\PYGZus{}\PYGZlt{}E\PYGZgt{}\PYGZus{}stat (static\PYGZus{}to\PYGZus{}neb)
    neb\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}opt1 (neb)
        neb\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}opt2 (neb)
            neb\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}stat (neb\PYGZus{}static)
    neb\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}opt2 (neb)
    neb\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}stat (neb\PYGZus{}static)
\PYGZob{}end\PYGZcb{}
\end{Verbatim}

\end{itemize}

Full example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}recipe
perfect\PYGZus{}opt1 (lowmesh)
    perfect\PYGZus{}opt2
        perfect\PYGZus{}stat (static)
        \PYGZob{}begin\PYGZcb{}
        inducescaling\PYGZus{}\PYGZlt{}S\PYGZgt{}
            inducedefect\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}N\PYGZgt{} (inducedefect)
                defect\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}opt1 (lowmesh\PYGZus{}defect)
                    defect\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}opt2 (defect\PYGZus{}relax)
                        defect\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (static)
        \PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
defect\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (static)
    phonon\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}\PYGZlt{}P\PYGZgt{} (phonon)
\PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
defect\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (static\PYGZus{}to\PYGZus{}neb), defect\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (static\PYGZus{}to\PYGZus{}neb)
    neb\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}opt1 (neb\PYGZus{}to\PYGZus{}neb)
        neb\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}opt2 (neb\PYGZus{}to\PYGZus{}nebstat)
            neb\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (nebstat\PYGZus{}to\PYGZus{}phonon)
    neb\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}opt2 (neb\PYGZus{}to\PYGZus{}nebstat)
    neb\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (nebstat\PYGZus{}to\PYGZus{}phonon)
\PYGZob{}end\PYGZcb{}
\PYGZob{}begin\PYGZcb{}
neb\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (nebstat\PYGZus{}to\PYGZus{}phonon)
    phonon\PYGZus{}\PYGZlt{}S\PYGZgt{}\PYGZus{}\PYGZlt{}B\PYGZhy{}E\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}\PYGZlt{}P\PYGZgt{} (phonon)
\PYGZob{}end\PYGZcb{}
\PYGZdl{}end
\end{Verbatim}


\section{The Personal Recipe section}
\label{3_1_4_personalrecipe:the-personal-recipe-section}\label{3_1_4_personalrecipe::doc}
The \code{\$personal\_recipe} section of the input file is generated by MAST and appears in the recipe-local \code{input.inp} file in the recipe directory.

Here, any \textless{}S\textgreater{}, \textless{}N\textgreater{}, \textless{}B\textgreater{}, \textless{}E\textgreater{}, \textless{}B-E\textgreater{}, \textless{}Q\textgreater{}, and \textless{}P\textgreater{} tags are extracted from the input file and substituted into the recipe.

The personal recipe is a good way to check exactly which ingredients MAST is going to run.

If errors are spotted in this section once the recipe directory has been created, it is best to:
\begin{enumerate}
\item {} 
Remove the entire new recipe directory from \code{\$MAST\_SCRATCH}

\item {} 
Examine the original input file's \code{\$recipe} section for errors and edit and save it

\item {} 
Re-run \code{mast -i \textless{}inputfile\textgreater{}.inp} to create a new recipe directory in \code{\$MAST\_SCRATCH}

\end{enumerate}


\section{The Defects section}
\label{3_1_5_defects::doc}\label{3_1_5_defects:the-defects-section}
The \code{\$defects} section specifies defects by:
\begin{itemize}
\item {} \begin{description}
\item[{defect type:}] \leavevmode\begin{itemize}
\item {} 
vacancy

\item {} 
interstitial

\item {} 
substitution or antisite

\end{itemize}

\end{description}

\item {} 
defect coordinates

\item {} \begin{description}
\item[{defect element symbol}] \leavevmode\begin{itemize}
\item {} 
Note that if an \code{elementmap} subsection is given in {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}}, then the mapped designations \code{X1}, \code{X2}, and so on can be given instead of an element symbol.

\end{itemize}

\end{description}

\end{itemize}

The \code{coord\_type} keyword specifies fractional or cartesian coordinates for the defects.

The \code{threshold} keyword specifies the absolute threshold for finding the defect coordinate, since relaxation of the perfect structure may result in changed coordinates.

Example \code{\$defects} section:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}defects

coord\PYGZus{}type fractional
threshold 1e\PYGZhy{}4

vacancy 0 0 0 Mg
vacancy 0.5 0.5 0.5 Mg
interstitial 0.25 0.25 0 Mg
interstitial 0.25 0.75 0 Mg

\PYGZdl{}end
\end{Verbatim}

The above section specifies 4 point defects (2 vacancies and 2 interstitials) to be applied separately and independently to the structure. When combined with the correct recipe in {\hyperref[3_1_3_recipe::doc]{\emph{The Recipe section}}}, four separate ingredients, each containing one of the defects above, will be created.

Multiple point defects can be also grouped together as a combined defect within a \code{\textless{}defect label\textgreater{}} subsection such as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}defects

coord\PYGZus{}type fractional
threshold 1e\PYGZhy{}4

begin doublevac
vacancy 0.0 0.0 0.0 Mg
vacancy 0.5 0.5 0.5 Mg
end

interstitial 0.25 0.25 0 Mg
interstitial 0.25 0.75 0 Mg

\PYGZdl{}end
\end{Verbatim}

In this case, there will be three separate defect ingredients: one ingredient with two vacancies together (where the defect group is labeled \code{doublevac}), one interstitial, and another interstitial.


\subsection{Charges for defects}
\label{3_1_5_defects:charges-for-defects}
Charges can be specified as \code{charge=0,10}, where a comma denotes the lower and upper ranges for the charges.

Let's say we want a Mg vacancy with charges from 0 to 3 (0, 1, 2, and 3):

\begin{Verbatim}[commandchars=\\\{\}]
vacancy 0 0 0 Mg charge=0,3
\end{Verbatim}

Let's say we want a dual Mg vacancy with a charge from 0 to 3 and labeled as \href{mailto:Vac@Mg}{Vac@Mg}\href{mailto:-Vac@Mg}{-Vac@Mg}:

\begin{Verbatim}[commandchars=\\\{\}]
begin Vac@Mg\PYGZhy{}Vac@Mg
vacancy 0.0 0.0 0.0 Mg
vacancy 0.5 0.5 0.5 Mg
charge=0,3
end
\end{Verbatim}

For a single defect, charges and labels can be given at the same time:

Let's say we have a Mg vacancy with charges between 0 and 3, and we wish to label it as \href{mailto:Vac@Mg}{Vac@Mg}:

\begin{Verbatim}[commandchars=\\\{\}]
vacancy 0.0 0.0 0.0 Mg charge=0,3 label=Vac@Mg
\end{Verbatim}

The charge and label keywords are interchangeable, i.e. we could also have typed:

\begin{Verbatim}[commandchars=\\\{\}]
vacancy 0 0 0 Mg label=Vac@Mg charge=0,3
\end{Verbatim}

If you use charges in the defects section like this, then you must use a tagged \code{defect\_\textless{}N\textgreater{}\_\textless{}Q\textgreater{}} type recipe in {\hyperref[3_1_3_recipe::doc]{\emph{The Recipe section}}}.


\subsection{Phonons for defects}
\label{3_1_5_defects:phonons-for-defects}
Phonon calculations are described by a \emph{phonon center site} coordinate and a \emph{phonon center radius} in Angstroms. Atoms within the sphere specified by these two values will be included in phonon calculations.

For VASP, this inclusion takes the form of selective dynamics T T T for the atoms within the sphere, and F F F otherwise, in a phonon calculation (IBRION = 5, 6, 7, 8)

If the phonon center radius is 0, only the atom found at the phonon center site point will be considered.

To use phonons in the defects section, use the subsection keyword \code{phonon} followed by:
\begin{itemize}
\item {} 
A label for the phonon

\item {} 
The fractional coordinates for the phonon center site

\item {} 
A float value for the phonon center radius

\item {} 
An optional float value for the tolerance-matching threshold for matching the phonon center site (if this last value is not specified, 0.1 is used).

\end{itemize}

Multiple separate phonon calculations may be obtained for each defect, for example:

\begin{Verbatim}[commandchars=\\\{\}]
begin int1
interstitial 0.25 0.25 0.25 X2
phonon host3 0.3 0.3 0.4 2.5 0.01
phonon solute 0.1 0.1 0.2 0.5
end
\end{Verbatim}

In the example above, \emph{host3} is the label for the phonon calculation where (0.3, 0.3, 0.4) is the coordinate for the phonon center site, and 2.5 Angstroms is the radius for the sphere inside which to consider atoms for the phonon calculation. Points within 0.01 of fractional coordinates will be considered for matching the phonon center site.

In the example above, \emph{solute} is the label for the phonon calculation bounded within a 0.5 Angstrom radius centered at (0.1, 0.1, 0.2) in fractional coordinates. As no threshold value was given, points within 0.1 (default) of fractional coordinates will be considered for matching the phonon center site.

The recipe template file for phonons may include either the explicit phonon labels and other labels, or \textless{}S\textgreater{}, \textless{}N\textgreater{}, \textless{}Q\textgreater{}, \textless{}P\textgreater{}. See {\hyperref[3_1_3_recipe::doc]{\emph{The Recipe section}}}.

Because phonons are cycled with the defects, a new parent loop must be provided for the phonons, for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZob{}begin\PYGZcb{}
defect\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}stat (static)
    phonon\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}\PYGZlt{}P\PYGZgt{} (phonon)
        phonon\PYGZus{}\PYGZlt{}N\PYGZgt{}\PYGZus{}\PYGZlt{}Q\PYGZgt{}\PYGZus{}\PYGZlt{}P\PYGZgt{}\PYGZus{}parse (phononparse)
\PYGZob{}end\PYGZcb{}
\end{Verbatim}


\section{The NEB section}
\label{3_1_6_neb:the-neb-section}\label{3_1_6_neb::doc}
The \code{\$neb} section includes a subsection for each nudged-elastic-band hops.
\begin{itemize}
\item {} 
Each neb hop should be a subsection labeled with a name composed of a starting and ending defect group, connected with a dash, like \code{vac1-vac2}.
\begin{itemize}
\item {} 
These labels should correspond exactly to the labels given in {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}.

\end{itemize}

\item {} 
The subsection should also include the movement of each primary moving atom, including:
\begin{itemize}
\item {} 
The atom's element symbol: if an \code{elementmap} subsection is given in {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}}, then the mapped designations \code{X1}, \code{X2}, and so on can be given instead of an element symbol.

\item {} 
The starting and ending .defect group. as specified in the \code{\$defects} section, and then also indicate the movement of elements, and their closest starting and ending positions. These explicit positions disambiguate between possible interpolations.

\item {} 
The \code{images} keyword, which specifies the number of intermediate images.

\end{itemize}

\end{itemize}

Again, the \code{\$neb} section is tied to specific defect labels. The NEB ingredients must be able to find defects or defect groups with those labels.


\subsection{Charges for NEBs}
\label{3_1_6_neb:charges-for-nebs}
To enable charged-supercell NEBs, use \textless{}Q\textgreater{} tags for the defect and NEB ingredients in {\hyperref[3_1_3_recipe::doc]{\emph{The Recipe section}}} and also specify charges for the defects in {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}.

The NEB ingredients will only be run for charges in the charge ranges of both parent endpoints.

For example, if defect parent vac1 has a charge range of charge=-2,0 and defect parent vac2 has a charge range of charge=-1,3, then the NEB with the label vac1-vac2 will only run with supercell charges -1 and 0.


\subsection{Phonons for NEBs}
\label{3_1_6_neb:phonons-for-nebs}
Phonons may be specified within each NEB grouping, as in {\hyperref[3_1_5_defects::doc]{\emph{The Defects section}}}.

The presumed saddle point in an NEB is usually taken.
\begin{itemize}
\item {} 
To give the saddle point structure to the phonon calculation, in {\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}}, use \code{mast\_update\_children give\_saddle\_structure} for the NEB ingredient type of the NEB parent to the phonon calculation.

\item {} 
If the frequencies of a moving atom are desired for the phonon calculations, and if that atom is anticipated to pass from fractional coordinate 0 0 0 to fractional coordinate 0.5 0 0, then the phonon\_center\_site should be 0.25 0 0 (assuming a straight path), and the phonon\_center\_radius is probably about 1 Angstrom.

\end{itemize}

Example defect and NEB section together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}defects

coord\PYGZus{}type fractional
threshold 1e\PYGZhy{}4

vacancy 0.0 0.0 0.0 Mg label=vac1
vacancy 0.0 0.5 0.5 Mg label=vac2
interstitial 0.25 0.0 0.0 Al label=int1
interstitial 0.0 0.25 0.0 Al label=int2

\PYGZdl{}end

\PYGZdl{}neb

begin vac1\PYGZhy{}vac2
images 1
Mg, 0 0 0, 0 .5 0.5
end

begin int1\PYGZhy{}int2
Al, 0.25 0 0, 0 0.25 0
images 3
phonon movingatom 0.125 0.125 0.0 1.0
end

\PYGZdl{}end
\end{Verbatim}


\section{The Chemical Potentials section}
\label{3_1_7_chemicalpotentials:the-chemical-potentials-section}\label{3_1_7_chemicalpotentials::doc}
The \code{\$chemical\_potentials} section lists chemical potentials, used for defect formation energy calculations using the defect formation energy tool.

Currently, chemical potentials must be set ahead of time. Each chemical potential subsection may be labeled descriptively.

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}chemical\PYGZus{}potentials

begin Ga rich
Ga \PYGZhy{}3.6080
As \PYGZhy{}6.0383
Bi \PYGZhy{}4.5650
end

begin As rich
Ga \PYGZhy{}4.2543
As \PYGZhy{}5.3920
Bi \PYGZhy{}4.5650
end

\PYGZdl{}end
\end{Verbatim}


\section{The Summary section}
\label{3_1_8_summary:the-summary-section}\label{3_1_8_summary::doc}
The \code{\$summary} section of the input file will cause a \code{SUMMARY.txt} file to be printed into the recipe directory, once the recipe is complete.

Each line in the summary section follows the format:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZlt{}ingredient name search string\PYGZgt{} \PYGZlt{}summary information\PYGZgt{}
\end{Verbatim}
\begin{itemize}
\item {} 
\textless{}search string\textgreater{} is a search string for matching ingredient names.

\item {} 
\textless{}summary information\textgreater{} refers to a python file in \code{\textless{}MAST installation directory\textgreater{}/summary} which is supposed to extract information from a given ingredient directory.

\item {} 
For example, the following section would extract energies from each ingredient matching \code{vac} in its name.
\begin{quote}

\$summary
vac energy
\$end
\end{quote}

\end{itemize}


\chapter{Running MAST for real}
\label{5_0_runningmast:running-mast-for-real}\label{5_0_runningmast::doc}

\section{General notes}
\label{5_0_runningmast:general-notes}
Depending on your cluster, you might find it necessary to \emph{nice} your processes:

\begin{Verbatim}[commandchars=\\\{\}]
nice \PYGZhy{}n 19 mast \PYGZhy{}i input.inp
nice \PYGZhy{}n 19 mast
\end{Verbatim}

Nice-ing allows the headnode to put its regular functions before the MAST processes. MAST should start running within several seconds.


\section{Inputting an input file}
\label{5_0_runningmast:inputting-an-input-file}
To parse an input file, use

\begin{Verbatim}[commandchars=\\\{\}]
mast \PYGZhy{}i input.inp
\end{Verbatim}

or

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mast} \PYG{o}{\PYGZhy{}}\PYG{n}{i} \PYG{o}{/}\PYG{o}{/}\PYG{n}{full}\PYG{o}{/}\PYG{n}{path}\PYG{o}{/}\PYG{n}{to}\PYG{o}{/}\PYG{n+nb}{input}\PYG{o}{/}\PYG{n+nb}{file}\PYG{o}{/}\PYG{n}{myinput}\PYG{o}{.}\PYG{n}{inp}
\end{Verbatim}

If your input file specifies any POSCAR or CIF files:
\begin{itemize}
\item {} 
Those files must be in the same path as the original input file.

\item {} 
Those files may not be moved until the recipe is complete.

\end{itemize}

The input file will be parsed and a recipe directory should be created inside the \code{\$MAST\_SCRATCH} directory, with the appropriate ingredient subdirectories.

Look at the \code{input.inp}, \code{archive\_input\_options.txt}, and \code{archive\_recipe\_plan.txt} files in the recipe directory to see if the setup agrees with what you think it should be.


\section{Running MAST}
\label{5_0_runningmast:running-mast}
Running MAST is separate from inputting input files. Use this command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mast}
\end{Verbatim}

This command will do two things:
\begin{enumerate}
\item {} 
Submit all ingredient runs listed in the \code{\$MAST\_CONTROL/submitlist} list to the queue.
\begin{itemize}
\item {} 
The submission command (\code{sbatch}, \code{qsub}, etc.) is based on the platform chosen when you set \code{\$MAST\_PLATFORM}. See {\hyperref[1_0_installation::doc]{\emph{Installation}}}.

\item {} 
The exact commands can be found in your MAST installation path under \code{submit/platforms/\textless{}platform name\textgreater{}/queue\_commands.py}.

\end{itemize}

\end{enumerate}

Individual ingredients' submission scripts are created automatically through a combination of {\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}} in the input file, and your the template submission script for your platform
\begin{itemize}
\item {} 
The template submission script is found in your MAST installation path under \code{submit/platforms/\textless{}platform name\textgreater{}/submit\_template.sh}).

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Spawn a MAST monitor, or \emph{mastmon}, process on the queue.

\end{enumerate}
\begin{itemize}
\item {} 
The \code{mastmon\_submit.sh} and \code{runmast.py} files, originally located in your MAST installation path \code{submit/platforms/\textless{}platform name\textgreater{}} and \code{submit} folders, respectively, and then copied into \code{\$MAST\_CONTROL} when you first run mast, are are responsible for submitting this process.

\item {} 
The script should be set up to use the shortest, fastest turnover queue available (e.g. a serial queue with a maximum walltime of 4 hours, or morganshort on bardeen).

\item {} 
You may make changes directly in \code{\$MAST\_CONTROL/mastmon\_submit.sh}

\end{itemize}

The mastmon process will generate additional entries on \code{\$MAST\_CONTROL/submitlist}, but these entries will not be submitted to the queue until MAST is called again.


\subsection{The MAST monitor}
\label{5_0_runningmast:the-mast-monitor}
The MAST monitor, or mastmon, process goes through the \code{\$MAST\_SCRATCH} directory.
\begin{itemize}
\item {} 
It looks at the recipe directories under \code{\$MAST\_SCRATCH}.

\item {} 
For each recipe directory, the MAST monitor builds a {\hyperref[4_0_recipe::doc]{\emph{Recipes}}} plan object from information in the recipe directory, using a combination of the \code{input.inp} and \code{status.txt} files in the recipe directory.

\item {} 
MAST then uses the recipe plan object to assess the next steps appropriate for the recipe, creating objects for the separate {\hyperref[2_0_ingredients::doc]{\emph{Ingredients}}} and evaluating them.

\end{itemize}


\subsection{Troubleshooting in a recipe directory}
\label{5_0_runningmast:troubleshooting-in-a-recipe-directory}
For human troubleshooting of a recipe, the \code{archive\_recipe\_plan.txt} file gives information about which ingredients are parents/children of which other ingredients, and which method each parent should use to update each of its child ingredients.

The \code{status.txt} files gives the status of each ingredient.

Ingredient statuses are:
\begin{itemize}
\item {} 
I = initialized: The ingredient has just been created from inputting the input file, but nothing has been run.

\item {} 
W = waiting: The ingredient is waiting for parents to complete before it can be staged.

\item {} 
S = staged: All parents have updated this child, but the run is not yet ready to run

\item {} 
P = proceed: The ingredient has written its input files, all parents have updated it, and its run method has been called. The run method usually adds the ingredient to the list at \code{\$MAST\_CONTROL/submitlist}, to be submitted to the queue the next time mast is called. There is no MAST status change between an ingredient proceeding to the submitlist and being submitted to the queue off of the submitlist. However, \code{\$MAST\_CONTROL/submitted} can be used to see which ingredients were just submitted to the queue.

\item {} 
C = complete: The ingredient is complete

\item {} 
E = error: The ingredient has errored out, and \code{mast\_auto\_correct} was set to False in the input file (the default is True)

\item {} 
skip = skip: You can set ingredients to skip in the status.txt file by manually editing the file.

\end{itemize}

The MAST monitor checks the status of all ingredients whose status is not yet complete. The MAST monitor updates each ingredient status in the recipe plan.

Each non-complete ingredient is checked to see if it is complete (this is a redundant fast-forward check, since sometimes it is useful to copy over previously completed runs into a MAST ingredient directory.)

If complete, the ingredient updates its children and is changed to Complete

For each Initialized ingredient:
\begin{itemize}
\item {} 
If the ingredient has any parents, it is given status Waiting

\item {} 
Otherwise, it is given status Staged

\end{itemize}

For each Proceed-to-run ingredient:
\begin{itemize}
\item {} 
If the ingredient is now complete, it updates its children and is changed to Complete

\end{itemize}

For each Waiting ingredient:
\begin{itemize}
\item {} 
If all parents are now marked complete, the ingredient is changed to Staged

\end{itemize}

For each Staged ingredient:
\begin{itemize}
\item {} 
If the ingredient is not already ready to run, its write method is called for it to write its input files.

\item {} 
The ingredient.s run method is called, which usually adds its folder to \code{\$MAST\_CONTROL/submitlist}, except in the case of special run methods like run\_defect (to induce a defect)

\item {} 
The ingredient.s status is changed to Proceed.

\end{itemize}

When all ingredients in a recipe are complete, the entire recipe folder is moved from \code{\$MAST\_SCRATCH} to \code{\$MAST\_ARCHIVE}


\subsection{The CONTROL folder}
\label{5_0_runningmast:the-control-folder}
The \code{\$MAST\_CONTROL} folder houses several files:
\begin{itemize}
\item {} 
errormast: Contains any queue errors from running the MAST monitor on the queue

\item {} 
mastoutput: Contains all queue output from running the MAST monitor on the queue, including a printout of the ingredient statuses for all recipes in the \$MAST\_SCRATCH directory

\item {} 
submitlist: The list of all ingredient folders to be submitted to the queue

\item {} 
submitted: A list of all ingredients submitted to the queue the last time the MAST monitor ran

\item {} 
mast.log and archive.\textless{}timestamp\textgreater{}.log: contains MAST runtime information

\end{itemize}

Every file except \code{submitlist} can be periodically deleted to save space.

The \code{errormast} file is written when there is an error, and will need to be deleted for MAST to continue running.


\subsection{The SCRATCH folder}
\label{5_0_runningmast:the-scratch-folder}
The \code{\$MAST\_SCRATCH} folder houses all recipe folders. It also houses a \code{mast.write\_files.lock} file while the MAST monitor is running, in order to prevent several versions of MAST from running at once and simultaneously checking and writing ingredients.
\begin{itemize}
\item {} 
Occasionally, MAST may report that it is locked. If there is no \emph{mastmon} process running or queued on the queue, you may delete the \code{mast.write\_files.lock} file manually.

\end{itemize}


\subsubsection{Skipping recipes or ingredients in the SCRATCH folder}
\label{5_0_runningmast:skipping-recipes-or-ingredients-in-the-scratch-folder}
If a certain recipe has some sort of flaw, or if you want to stop tracking it halfway through, you may have MAST skip over this recipe:
\begin{itemize}
\item {} 
Create an empty (or not, the contents do not matter) file named \code{MAST\_SKIP} in the recipe directory.

\item {} 
Go through \$MAST\_CONTROL/submitlist and delete all ingredients associated with that recipe to keep them from being submitted during the next MAST run.

\end{itemize}

If you would like to skip certain ingredients of a single recipe, edit the recipe's status.txt file and replace ingredients to be skipped with the status \emph{skip} (use the whole word).
\begin{itemize}
\item {} 
To un-skip these ingredients, set them back to W for waiting for parents in status.txt.
\begin{itemize}
\item {} 
\textbf{Be careful if deleting any files for skipped ingredients.}

\item {} 
\textbf{Do not delete the metadata.txt file.}

\item {} 
\textbf{If deleting a file that was obtained from a parent, like a POSCAR file, also set the parent ingredient back to P when you un-skip the child ingredient.}

\end{itemize}

\item {} 
No recipe can be considered complete by MAST if it includes skipped ingredients. However, if you consider the recipe complete, you can move the entire recipe directory out of \code{\$MAST\_SCRATCH} and into \code{\$MAST\_ARCHIVE} or another directory.

\end{itemize}


\subsection{The ARCHIVE folder}
\label{5_0_runningmast:the-archive-folder}
When all ingredients in a recipe are complete, the entire recipe directory is moved from \code{\$MAST\_SCRATCH} to \code{\$MAST\_ARCHIVE}.


\section{Running MAST repeatedly}
\label{5_0_runningmast:running-mast-repeatedly}
The command \code{mast} needs to be run repeatedly in order to move the status of the recipe forward. In order to run mast automatically, use a crontab.

Important notes:
\begin{itemize}
\item {} 
Some clusters may not allow the use of cron. Please check the cluster policy before setting up cron.

\item {} 
Be ready for a lot of notification emails. Crontab on a well-behaved system should send you an email each time it runs, giving you what would have been the output on the screen.

\item {} 
Include \code{. \$HOME/.bashrc} or a similar line to get your MAST environment variables and your usual path setup.

\end{itemize}

Crontab commands are as follows:
\begin{itemize}
\item {} 
\code{crontab -e} to edit your crontab

\item {} 
\code{crontab -l} to view your crontab

\item {} 
\code{crontab -r} to remove your crontab

\end{itemize}

This crontab line will run mast every hour at minute 15, and is usually suitable for everyday use:

\begin{Verbatim}[commandchars=\\\{\}]
15 * * * * . \PYGZdl{}HOME/.bashrc; nice \PYGZhy{}n 19 mast
\end{Verbatim}

This crontab line will run mast every 15 minutes and is ONLY suitable for short testing:

\begin{Verbatim}[commandchars=\\\{\}]
*/15 * * * * . \PYGZdl{}HOME/.bashrc; nice \PYGZhy{}n 19 mast
\end{Verbatim}


\chapter{MAST post-processing utilities}
\label{6_0_postprocessingtools::doc}\label{6_0_postprocessingtools:mast-post-processing-utilities}
These utilities are meant to be used as part of a MAST workflow.
See example files in \code{\$HOME/MAST/examples} or wherever you may have moved the initally-created \code{\$HOME/MAST/examples} folder for examples on how to use them.

These utilities should have been copied into your bin or .local/bin directory (see {\hyperref[1_0_installation::doc]{\emph{Installation}}}).


\section{Defect formation energy with finite-size scaling}
\label{6_0_postprocessingtools:defect-formation-energy-with-finite-size-scaling}
Initially determining the sizes for finite-size scaling is covered in {\hyperref[3_1_1_structure::doc]{\emph{The Structure section}}} with the utility \code{mast\_finite\_size\_scaling\_sizes}.

The \code{mast\_madelung\_utility} utility runs as the last ingredient in a finite-size scaling defect workflow (see \code{\$HOME/MAST/examples/finite\_size\_scaling.inp}).

Run the utility as \code{mast\_madelung\_utility}. All inputs are derived from the recipe-local \code{input.inp} file in the recipe directory.
\begin{itemize}
\item {} 
The utility should generate a series of tables and .png plots that display the finite-size-scaling-corrected and original defect formation energies for different chemical potentials.

\item {} 
{\hyperref[3_1_7_chemicalpotentials::doc]{\emph{The Chemical Potentials section}}} of the input file should be set in order for the utility to work.

\end{itemize}


\section{Defect formation energy versus Fermi energy}
\label{6_0_postprocessingtools:defect-formation-energy-versus-fermi-energy}
The \code{mast\_defect\_formation\_energy} tool plots defect formation energy versus Fermi energy.

The defect formation energy tool is intended to be run as another ingredient folder in the recipe directory.

If you do not have such an ingredient in the recipe directory, you may manually create the ingredient folder and give it a \code{dfe\_input.txt} file.

The \code{dfe\_input.txt} file for a manually-created or embedded workflow ingredient (see \code{//home/\textless{}username\textgreater{}/MAST/example/defect\_formation\_energy.inp}) should contain the following information:

\begin{Verbatim}[commandchars=\\\{\}]
dfe\PYGZus{}label1=perfect\PYGZus{}label defected\PYGZus{}label
dfe\PYGZus{}label2=perfect\PYGZus{}label defected\PYGZus{}label
dfe\PYGZus{}label3=perfect\PYGZus{}label defected\PYGZus{}label
(etc. for more defects)
bandgap\PYGZus{}lda\PYGZus{}or\PYGZus{}gga=\PYGZlt{}float\PYGZgt{}
bandgap\PYGZus{}hse\PYGZus{}or\PYGZus{}expt=\PYGZlt{}float\PYGZgt{}
plot\PYGZus{}threshold \PYGZlt{}float\PYGZgt{}: Plotting threshold value
\end{Verbatim}
\begin{itemize}
\item {} 
\textless{}perfect\_label\textgreater{} and \textless{}defected\_label\textgreater{} are the ingredient names of the perfected and corresponding defected cells.

\item {} 
bandgap\_lda\_or\_gga should be a float value indicating a DFT-calculated bandgap, usually expected to be underestimated.

\item {} 
bandgap\_hse\_or\_expt should be a float value indicating an experimental or more accurate bandgap, e.g. from a hybrid calculation.

\item {} 
plot\_threshold should be a float value indicating the threshold for transitions.

\item {} 
In addition, {\hyperref[3_1_7_chemicalpotentials::doc]{\emph{The Chemical Potentials section}}} should exist in the \code{input.inp} input file inside the recipe directory.

\end{itemize}

Run the utility as:

\begin{Verbatim}[commandchars=\\\{\}]
mast\PYGZus{}defect\PYGZus{}formation\PYGZus{}energy dfe\PYGZus{}input.txt
\end{Verbatim}

A directory named \code{dfe\_results} should be created within the ingredient directory. Inside that directory:
\begin{itemize}
\item {} 
The two-column printout for each chemical potential-labeled text file contains Fermi energy on the left, and defect formation energy on the right.

\item {} 
The \code{dfe.txt} printout contains defect formation energy information for each charge state.

\end{itemize}


\section{Diffusion coefficient}
\label{6_0_postprocessingtools:diffusion-coefficient}
The \code{mast\_diffusion\_coefficient} diffusion coefficient calculation tool supports the 5(fcc) and 8(hcp) frequency models as follows:
\begin{itemize}
\item {} 
Five-frequency model equation from R. E. Howard and J. R. Manning, Physical Review, Vol. 154, 1967.

\item {} 
Eight-frequency model equation from P. B. Ghate, Physical Review, Vol. 133, 1963.

\end{itemize}

The tool is designed to be used as a separate ingredient within the recipe directory. See \code{\$HOME/MAST/examples/neb\_with\_phonons.inp} for an example input fileof a full workflow.

If the ingredient was not created within the workflow, an ingredient directory may be manually created for the tool.

The tool will use an input text file like \code{diffcoeff\_input.txt}, which should contain the following lines. The order of the lines does not matter.
\begin{itemize}
\item {} 
Names of the directories of energies and attempt rates, which are specified with respect to different frequencies for the model:
\begin{itemize}
\item {} 
\textbf{E} and \textbf{v} means energy and attempt rate, respectively. (There is no support for other characters such as w).

\item {} 
For 5-freq, \textbf{E0 through E4} should be used to specify the relations with certain directories

\item {} 
For 8-freq, \textbf{Ea, Eb, Ec, EX, Eap (p means prime), Ebp, Ecp, and EXp} should be used. Note they are all case sensitive and should be exactly the same as written here.

\item {} 
Generally speaking, each keyword (Exx or vxx) is followed by two ingredient names.
\begin{itemize}
\item {} 
The first name indicates the ingredient name corresponding to the configuration of the starting point of NEB.

\item {} 
The second name indicates the ingredient name corresponding to the configuration of the saddle point of the NEB.

\item {} 
This order should not be changed.

\item {} 
For each name, the utility will expect two files to be present within the ingredient diretory of the diffusion coefficient tool:
\begin{itemize}
\item {} 
\textless{}ingredient\_name\textgreater{}\_OUTCAR

\item {} 
\textless{}ingredient\_name\textgreater{}\_OSZICAR

\item {} 
If you are manually creating a diffusion coefficient tool ingredient, you will have to manually copy files from each of the completed ingredients specified.

\end{itemize}

\end{itemize}

\item {} 
The user can also type only one single float behind the keyword, and the code will then not refer to the directory for the related energy or attempting rate, but simply use the data given.

\end{itemize}

\item {} 
\textbf{type} means which frequency model to choose. Either \code{5} or \code{fcc} tells the code that the five-frequency model should be applied, while either \code{8} or \code{hcp} tell the code that the eight-frequency model should be applied.

\item {} 
\textbf{HVf} means the formation energy of the vacancy
\begin{itemize}
\item {} 
Either 1 float or two ingredient names are expected after this keyword.

\item {} 
If ingredient names are used, in the order \textless{}perfect\_ingredient\textgreater{} \textless{}defected\_ingredient\textgreater{}, then the utility will expect two energy files to be present in the utility's ingredient directory:
\begin{itemize}
\item {} 
\textless{}perfect\_ingredient\textgreater{}\_OSZICAR

\item {} 
\textless{}defected\_ingredient\textgreater{}\_OSZICAR

\item {} 
Charged defects are not currently supported.

\end{itemize}

\end{itemize}

\item {} 
\textbf{HB} means the binding energy, and is only applicable for the 8-frequency model.
\begin{itemize}
\item {} 
Either 1 float or four ingredient names are expected after this keyword.

\item {} 
If ingredient names are used:
\begin{itemize}
\item {} 
Use the order \textless{}perfect ingredient\textgreater{} \textless{}vacancy and substitution\textgreater{} \textless{}substitution only\textgreater{} \textless{}vacancy only\textgreater{}

\item {} 
Supply an \textless{}ingredient\_name\textgreater{}\_OSZICAR file in the utility's ingredient directory.

\end{itemize}

\end{itemize}

\item {} 
\textbf{lattice} indicates the ingredient name for the ingredient in which to find a lattice file.
\begin{itemize}
\item {} 
This ingredient typically corresponds to an undefected supercell.

\item {} 
The utility expects to find a \textless{}lattice\_ingredient\_name\textgreater{}\_POSCAR file inside the diffusion coefficient utility ingredient directory.

\end{itemize}

\item {} 
\textbf{plotdisplay} indicates whether to use matplotlib.pyplot in order to create a plot, or whether to skip plotting.
\begin{itemize}
\item {} 
Use ``plotdisplay none'' to skip plotting

\item {} 
Omit this keyword to use a default display

\item {} 
Use ``plotdiplay tkagg'' etc. or another display string to specify a matplotlib display.

\end{itemize}

\end{itemize}

Run as \code{mast\_diffusion\_coefficient -i \textless{}input\textgreater{}}


\chapter{Standalone Tools}
\label{8_0_standalonetools:standalone-tools}\label{8_0_standalonetools::doc}

\section{Defect Finder}
\label{8_0_standalonetools:defect-finder}
The defect finder takes a POSCAR file and finds vacancies and interstitials.
The defect finder currently exists in a separate repository.
You may test it online at materialshub.org \textgreater{} Resources \textgreater{} Tools \textgreater{} Defect Finder


\section{Effective Grain Boundary Diffusivity Calculator}
\label{8_0_standalonetools:effective-grain-boundary-diffusivity-calculator}

\subsection{Effective Grain Boundary Diffusivity Calculator}
\label{8_0_2_gbdiff:effective-grain-boundary-diffusivity-calculator}\label{8_0_2_gbdiff::doc}
Author: Jie Deng

Calculates the effective diffusivity in a grain boundary network with two types of randomly distributed grain boundaries.

\href{https://materialshub.org/resources/diffcalc}{Version 1.3 - published on 21 Feb 2014}

\href{https://materialshub.org/resources/gbdiff}{Look for a new version in late 2014}

The source code must be downloaded from github. It does not exist in the pypi package. See {\hyperref[12_0_programming::doc]{\emph{Programming for MAST}}}.
\begin{itemize}
\item {} 
Uncompiled source code is in MAST/utility/gbdiff

\end{itemize}

This tool calculates the effective diffusivity in a grain boundary network represented by a three-dimensional Voronoi diagram.
Two types of grain boundaries with different diffusivities are randomly distributed in the domain.
The effective diffusivity is calculated using the mean squared displacement method, where periodic boundary conditions are applied in all directions.
Users are free to choose the fraction of each grain boundary type as well as the activation energy and pre-factor for each grain boundary diffusivity.


\subsection{Cite this work}
\label{8_0_2_gbdiff:cite-this-work}
Researchers should cite this work as follows:

\begin{Verbatim}[commandchars=\\\{\}]
Jie Deng (2014), \PYGZdq{}Effective Grain Boundary Diffusivity Calculator,\PYGZdq{} https://materialshub.org/resources/diffcalc.

@misc \PYGZob{} 30,
    title = \PYGZob{}Effective Grain Boundary Diffusivity Calculator\PYGZcb{},
    month = \PYGZob{}Jan\PYGZcb{},
    url = \PYGZob{}https://materialshub.org/resources/30\PYGZcb{},
    year = \PYGZob{}2014\PYGZcb{},
    author = \PYGZob{}Deng , Jie\PYGZcb{}
\PYGZcb{}
\end{Verbatim}


\section{Particle Trajectory Diffusion Analyzer}
\label{8_0_standalonetools:particle-trajectory-diffusion-analyzer}

\subsection{Particle Trajectory Diffusion Analysis}
\label{8_0_3_diffanalyzer:particle-trajectory-diffusion-analysis}\label{8_0_3_diffanalyzer::doc}
Author: Leland Barnard
Acknowledgments to: Amy Bengtson, Saumitra Saha

Computes mean squared displacements and tracer diffusion coefficients from particle position data as a function of time.

\href{https://materialshub.org/resources/diffanalyzer}{Version 1.13 - published on 28 Mar 2014}

The source code must be downloaded from github. It does not exist in the pypi package. See {\hyperref[12_0_programming::doc]{\emph{Programming for MAST}}}.
\begin{itemize}
\item {} 
Uncompiled source code is in MAST/utility/diffanalyzer

\end{itemize}

This tool takes as input particle position data from methods such as molecular dynamics or kinetic Monte Carlo and computes the mean squared displacement for all particles as a function of time.
For a system with multiple types of particles, the mean squared displacement is computed for each particle type.
The tracer diffusion coefficient is then calculated from the slope of the mean squared displacement vs time curve.

The tool is based on \emph{The Working Man's Guide to Obtaining Self Diffusion Coefficients from Molecular Dynamics Simulations} by Professor David Keffer from UT Knoxville.


\subsubsection{Input file format:}
\label{8_0_3_diffanalyzer:input-file-format}
This tool reads in atomic position data in the VASP XDATCAR format. This file format begins with the following set of lines:

\begin{Verbatim}[commandchars=\\\{\}]
Name
C1 C2 C3 ...
N1 N2 N3 ...
Direct
\end{Verbatim}
\begin{itemize}
\item {} 
The first line is a name or description of the file. It is not read by the tool.

\item {} 
The second line are the names of the components in the system. These will be element names in the case of an atomic simulation.

\item {} 
The third line are the number of particles of each component in the system.

\item {} 
The final line is a VASP generated line that specifies direct atomic coordinates.

\item {} 
Following these 4 lines, the file must have 1 blank line, and then the particle position data begins on line 6. Particle positions must be in fractional or direct coordinates, and a single line must separate the blocks of particle positions at each time step throughout the file.

\end{itemize}


\subsubsection{Calculation of error on the diffusion coefficient:}
\label{8_0_3_diffanalyzer:calculation-of-error-on-the-diffusion-coefficient}
The error bars on the mean squared displacements represent a single standard deviation in the measurements of the squared displacements over all time origins.

The error in the diffusion coefficient represents the standard error in the slope of the weighted least squares fit to the mean squared displacement, using the variance in the squared displacements as the error weight.


\subsubsection{References}
\label{8_0_3_diffanalyzer:references}
``The Working Man's Guide to Obtaining Self Diffusion Coefficients from Molecular Dynamics Simulations'' by Professor David Keffer from UT Knoxville, which may be found here: \href{http://www.cs.unc.edu/Research/nbody/pubs/external/Keffer/selfD.pdf}{http://www.cs.unc.edu/Research/nbody/pubs/external/Keffer/selfD.pdf}


\subsubsection{Cite this work}
\label{8_0_3_diffanalyzer:cite-this-work}
Researchers should cite this work as follows:

\begin{Verbatim}[commandchars=\\\{\}]
Leland Barnard (2014), \PYGZdq{}Particle Trajectory Diffusion Analysis,\PYGZdq{} https://materialshub.org/resources/diffanalyzer.

@misc \PYGZob{} 31,
    title = \PYGZob{}Particle Trajectory Diffusion Analysis\PYGZcb{},
    month = \PYGZob{}Feb\PYGZcb{},
    url = \PYGZob{}https://materialshub.org/resources/31\PYGZcb{},
    year = \PYGZob{}2014\PYGZcb{},
    author = \PYGZob{}Barnard , Leland\PYGZcb{}
\PYGZcb{}
\end{Verbatim}


\section{Diffusion Connectivity}
\label{8_0_standalonetools:diffusion-connectivity}

\subsection{Diffusion Connectivity}
\label{8_0_1_diffusionconnectivity::doc}\label{8_0_1_diffusionconnectivity:diffusionconnectivity}\label{8_0_1_diffusionconnectivity:diffusion-connectivity}
A new section is introduced in the input file:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}site
int1
0.5 0.5 0.5
0.5 0 0
0 0.5 0
0 0 0.5
int2
0.25 0.25 0.25
0.75 0.25 0.25
0.25 0.75 0.25
0.25 0.25 0.75
0.75 0.75 0.75
0.25 0.75 0.75
0.75 0.25 0.75
0.75 0.75 0.25
\PYGZdl{}end
\end{Verbatim}

In this example, there are two types of local minimum (interstitial site) int1 and int2. The geometrically equivalent site coordinates are listed for each type.

The create\_paths.py code first parses the perfect lattice with the defect sites, then finds the nth neighbor of possible pairs of both same and different site types, and detect if the path candidate crosses over the host lattice site or another defect site and delete it.
If the lattice user provides is too small and not all the neighbors (up to nth) are found, the code will double, triple, etc. the size until all required neighbor pairs are found.

The NEBcheck.py code will generate the MAST-input style defect structure for the possible pairs found in the create\_paths.py and write a new input file that calls MAST to generate NEB and phonon folders to check if these paths are appropriate. Currently the code ends at calling MAST and does not yet manage to handle the NEB and phonon results analysis.

The usage is: python NEBcheck.py -i \textless{}input\textgreater{} -n \textless{}up-to-nth-neighbor\textgreater{}


\chapter{Programming for MAST}
\label{12_0_programming:programming-for-mast}\label{12_0_programming::doc}

\section{Object hierarchy}
\label{12_0_programming:object-hierarchy}
Several objects are created in MAST. The classes for these objects are in similarly named files, for example, class MyClass in file myclass.py.
\begin{itemize}
\item {} 
When the user types \code{mast} or when crontab executes \code{mast}, a \textbf{MAST monitor} object is created (class MASTmon in MAST). This monitor is responsible for looking through the \code{\$MAST\_SCRATCH} directory for recipe folders.

\item {} 
For each recipe folder,
\begin{itemize}
\item {} 
An \textbf{Input Options} object is created from the \code{input.inp} file (class InputOptions in MAST/utility, parsed from the input file through class InputParser in MAST/parsers)

\item {} 
A \textbf{Recipe Plan} object is created from that Input Options object

\end{itemize}

\item {} 
The status of the ingredients in the recipe is given by \code{status.txt}
\begin{itemize}
\item {} 
Depending on the ingredient status, an \textbf{Ingredient} object is created using information from the Recipe Plan object (class ChopIngredient, inheriting from class BaseIngredient, in MAST/ingredients)

\item {} 
That Ingredient object may involve several \textbf{Checker} objects for different programs based on the \code{mast\_program} keyword of its ingredient type in {\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}} (class XXXChecker, MAST/ingredients/checker)

\end{itemize}

\end{itemize}


\section{Code hooks in the input file}
\label{12_0_programming:code-hooks-in-the-input-file}
The most common modifications to MAST are expected to be:
\begin{itemize}
\item {} 
Adding support for new programs, e.g. besides VASP

\item {} 
Adding new parent-child information transfer methods, for example:
\begin{itemize}
\item {} 
Giving additional information to a child ingredient, like number of pairs

\item {} 
Accommodating different run structures, for example, forward on the least symmetric structure among several folders in the parent ingredient

\end{itemize}

\end{itemize}

Both of these modifications are currently coded in \code{MAST/ingredients/chopingredient.py} and in \code{MAST/ingredients/checker}

In the input file, the \code{mast\_xxxx\_method} keywords are direct hooks to methods in the \textbf{ChopIngredient} class.
\begin{itemize}
\item {} 
Methods are separated by semicolons, and can include arguments (see {\hyperref[3_1_2_ingredients::doc]{\emph{The Ingredients section}}}.)

\item {} 
The method in the ChopIngredient class may involve a checker, if they are generic but require program-specific treatment, for example, \code{forward\_final\_structure}.

\item {} 
Or, the method in the ChopIngredient class may not need a checker, if it is totally generic, for example, \code{copy\_file OLDNAME NEWNAME}

\item {} 
When used as an update method, please remember that the last argument to a method is going to be the child ingredient's directory, as determined by {\hyperref[3_1_4_personalrecipe::doc]{\emph{The Personal Recipe section}}} in the recipe folder.

\end{itemize}

Support for using a new checker type as self.checker in a ChopIngredient class would need to be added at the top of \code{MAST/ingredients/baseingredient.py}.
Alternately, a new checker instance may be initialized on-the-fly within a method, e.g. mychecker = VASPChecker(name=mydirectory)


\section{Source code}
\label{12_0_programming:source-code}
To program with MAST, clone from the dev branch at \href{https://github.com/uw-cmg/MAST}{the MAST github repository}

Prepend the clone directory to your \code{\$PYTHONPATH} environment variable.

The command \code{mast} should reveal the clone directory instead of any other MAST installation directories.

To run unit tests and verify that the MAST code is sound, go to the test directory in \code{\textless{}clone directory\textgreater{}/MAST/test} and run the command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{nosetests} \PYG{o}{\PYGZhy{}}\PYG{n}{v} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{nocapture}
\end{Verbatim}

The \code{nocapture} option allows print statements.
The \code{verbose} option gives verbose results.

The development team may have designated some tests to be skipped. However, any errors should be reported to the development team.


\chapter{Acknowledgments}
\label{10_0_acknowledgments::doc}\label{10_0_acknowledgments:acknowledgments}

\section{The MAST Team}
\label{10_0_acknowledgments:the-mast-team}
PI: Professor Dane Morgan

All inquiries should be directed to \href{mailto:ddmorgan@wisc.edu}{ddmorgan@wisc.edu}


\subsection{Current Team}
\label{10_0_acknowledgments:current-team}
The following team members are arranged by start date and then alphabetically by last name. (+) indicates research performed using MAST.
\begin{itemize}
\item {} 
Tam Mayeshiba + (summer 2010 - present)

\item {} 
Dr. Henry Wu + (summer 2013 - present)

\item {} 
Amy Kaczmarowski (fall 2013 - present)

\item {} 
Zhewen Song + (fall 2013 - present)

\item {} 
Wei Xie (fall 2013 - present)

\item {} 
Ben Afflerbach (fall 2014 - present)

\end{itemize}


\subsection{Alumni}
\label{10_0_acknowledgments:alumni}\begin{itemize}
\item {} 
Tom Angsten + (spring 2011 - summer 2013)

\item {} 
Dr. Glen Jenness + (spring 2013 - summer 2013)

\item {} 
Kumaresh Visakan Murugan (spring 2013, fall 2013, spring 2014)

\item {} 
Hyunwoo Kim (spring 2013)

\item {} 
Parker Sear (spring 2013 - summer 2013, spring 2014)

\item {} 
Nada Alameddine (summer 2013)

\item {} 
Jihad Naja (summer 2013)

\item {} 
Jesus Chavez (summer 2014)

\item {} 
Saswati De (summer 2014)

\item {} 
Chandana Hosamane Kabbali (summer 2014)

\end{itemize}


\section{NSF}
\label{10_0_acknowledgments:nsf}
\scalebox{0.500000}{\includegraphics{nsf1.jpg}}

The MAterials Simulation Toolkit (MAST) was developed with funding from the National Science Foundation Grant 1148011. T. Mayeshiba gratefully acknowledges support from the National Science Foundation Graduate Research Fellowship Grant No. DGE-0718123.


\section{pymatgen}
\label{10_0_acknowledgments:pymatgen}
\scalebox{0.500000}{\includegraphics{pymatgen.png}}

Many underlying MAST functions are built using pymatgen (\href{http://pymatgen.org}{http://pymatgen.org}), and the MAST team would especially like to thank pymatgen developers Shyue Ping Ong and Anubhav Jain for their assistance.


\chapter{Citations}
\label{15_0_citations:citations}\label{15_0_citations::doc}

\section{Citing MAST}
\label{15_0_citations:citing-mast}
To properly cite MAST and its dependencies, go to your completed recipe directory in \code{\$MAST\_ARCHIVE} and locate the following file

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CITATIONS}\PYG{o}{.}\PYG{n}{bib}
\end{Verbatim}

For example:

\begin{Verbatim}[commandchars=\\\{\}]
cat \PYGZdl{}MAST\PYGZus{}ARCHIVE/Optimization\PYGZus{}Al\PYGZus{}20140101T120000/CITATIONS.bib
\end{Verbatim}

This Bibtex-formatted file may be used directly with LaTeX or imported into a reference manager such as EndNote or Mendeley.


\section{Full list of possible citations}
\label{15_0_citations:full-list-of-possible-citations}
MAST chooses from the following citations when writing the \code{CITATIONS.bib} file:


\subsection{MAST}
\label{15_0_citations:mast}\begin{itemize}
\item {} 
MAST development team. MAterials Simulation Toolkit (MAST). (2014). at \textless{}\href{http://pypi.python.org/pypi/MAST}{http://pypi.python.org/pypi/MAST}\textgreater{}

\item {} 
Angsten, T., Mayeshiba, T., Wu, H. \& Morgan, D. Elemental vacancy diffusion database from high-throughput first-principles calculations for fcc and hcp structures. New J. Phys. 16, 015018 (2014).

\item {} 
Kaczmarowski, A. Structopt package for implementing genetic algorithms on clusters. (2014). at \textless{}\href{https://pypi.python.org/pypi/MAST}{https://pypi.python.org/pypi/MAST}\textgreater{}

\end{itemize}


\subsection{pymatgen}
\label{15_0_citations:pymatgen}\begin{itemize}
\item {} 
Ong, S. P. et al. Python Materials Genomics (pymatgen): A robust, open-source python library for materials analysis. Comput. Mater. Sci. 68, 314-319 (2013).

\end{itemize}


\subsection{spglib}
\label{15_0_citations:spglib}\begin{itemize}
\item {} 
Togo, A. Spglib. (2009). at \textless{}\href{http://spglib.sourceforge.net/}{http://spglib.sourceforge.net/}\textgreater{}

\end{itemize}


\subsection{VASP}
\label{15_0_citations:vasp}

\subsubsection{VASP main program}
\label{15_0_citations:vasp-main-program}\begin{itemize}
\item {} 
Kresse, G. \& Furthmüller, J. Efficient iterative schemes for ab initio total-energy calculations using a plane-wave basis set. Phys. Rev. B 54, 11169-11186 (1996).

\item {} 
Kresse, G. \& Furthmüller, J. Efficiency of ab-initio total energy calculations for metals and semiconductors using a plane-wave basis set. Comput. Mater. Sci. 6, 15-50 (1996).

\item {} 
Kresse, G. \& Hafner, J. Ab initio molecular-dynamics simulation of the liquid-metal-amorphous-semiconductor transition in germanium. Phys. Rev. B 49, 14251-14269 (1994).

\item {} 
Kresse, G. \& Hafner, J. Ab initio molecular dynamics for liquid metals. Phys. Rev. B 47, 558-561 (1993).

\end{itemize}


\subsubsection{VASP pseudopotentials in general}
\label{15_0_citations:vasp-pseudopotentials-in-general}\begin{itemize}
\item {} 
Kresse, G. \& Hafner, J. Norm-conserving and ultrasoft pseudopotentials for first-row and transition elements. J. Phys. Condens. Matter 6, 8245-8257 (1994).

\end{itemize}


\subsubsection{VASP PAW pseudopotentials}
\label{15_0_citations:vasp-paw-pseudopotentials}\begin{itemize}
\item {} 
Kresse, G. \& Joubert, D. From ultrasoft pseudopotentials to the projector augmented-wave method. Phys. Rev. B 59, 1758-1775 (1999).

\end{itemize}


\subsubsection{Nudged Elastic Band Calculations with VASP}
\label{15_0_citations:nudged-elastic-band-calculations-with-vasp}\begin{itemize}
\item {} 
Henkelman, G. \& Jónsson, H. Improved tangent estimate in the nudged elastic band method for finding minimum energy paths and saddle points. J. Chem. Phys. 113, 9978 (2000).

\item {} 
Henkelman, G., Uberuaga, B. P. \& Jónsson, H. A climbing image nudged elastic band method for finding saddle points and minimum energy paths. J. Chem. Phys. 113, 9901 (2000).

\item {} 
Jónsson, H., Mills, G. \& Jacobsen, K. W. in Class. Quantum Dyn. Condens. Phase Simulations (Berne, B. J., Ciccotti, G. \& Coker, D. F.) 385 (World Scientific, 1998).

\item {} 
Sheppard, D. \& Henkelman, G. Paths to which the nudged elastic band converges. J. Comput. Chem. 32, 1769-71; author reply 1772-3 (2011).

\item {} 
Sheppard, D., Terrell, R. \& Henkelman, G. Optimization methods for finding minimum energy paths. J. Chem. Phys. 128, 134106 (2008).

\item {} 
Sheppard, D., Xiao, P., Chemelewski, W., Johnson, D. D. \& Henkelman, G. A generalized solid-state nudged elastic band method. J. Chem. Phys. 136, 074103 (2012).

\end{itemize}


\subsection{Contact us for corrections}
\label{15_0_citations:contact-us-for-corrections}
If you feel that we have missed or mis-typed a citation, please contact us ({\hyperref[14_0_contact::doc]{\emph{Contact Us}}}).


\chapter{Contact Us}
\label{14_0_contact:contact-us}\label{14_0_contact::doc}
All inquiries about MAST should be made to Dane Morgan at \href{mailto:ddmorgan@wisc.edu}{ddmorgan@wisc.edu}


\chapter{License}
\label{11_0_license::doc}\label{11_0_license:license}
The MAterials Simulation Toolkit is released with the MIT license, reproduced below:

Copyright (c) 2014 University of Wisconsin-Madison Computational Materials Group MAterials Simulation Toolkit (MAST) Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ``Software''), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
